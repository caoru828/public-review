面试复习
一．bfc原理
格式化上下文
是普通流。
它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。
触发bfc
•	float属性不为none
•	overflow不为visible(可以是hidden、scroll、auto)
•	position为absolute或fixed
•	display为inline-block、table-cell、table-caption
。bfc作用
1. 清除内部浮动
我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。
2. 垂直margin合并
在CSS当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
折叠的结果：
•	两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
•	两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
•	两个外边距一正一负时，折叠结果是两者的相加的和。
这个同样可以利用BFC解决。关于原理在前文已经讲过了。
3. 创建自适应两栏布局
在很多网站中，我们常看到这样的一种结构，左图片+右文字的两栏结构。

二 闭包，清楚闭包
    闭包是指外部函数里声明内部函数，内部函数引用外部函数里的局部变量，这样当外部函数调用完毕以后，局部变量不被释放，可以一直使用。
    具体应用：在一个ul里有多个li，单击li的时候显示自己的索引，实现方式是，在for循环给li绑定事件时，在for循环里添加函数立即调用，为这个函数立即调用传递i做为实参，定义index为形参。然后在这个函数立即调用里给li注册单击事件，在单击事件里alert函数立即调用中的形参index
-->
<ul id="ul1">
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
</ul>
<script>
    var oUl = document.getElementById('ul1');
    var aLi = oUl.getElementsByTagName('li');
    for(var i=0; i<aLi.length; i++){
        (function(index){
            aLi[i].onclick = function(){
                alert(index);
            };
        })(i);
}

三 字符串 -> 数字
1.parseInt()
2.number()
3.数据额运算

四 移动端 rem em
var width = docEl.getBoundingClientRect().width;
var rem = width / 7.5; // 将屏幕宽度分成7.5份， 1份为1rem  iphne6 375 / 7.5  1rem = 50
五 json.stringfy  对象转化成字符串  （前端）
json.parse 转化成json对象

parse用于从一个字符串中解析出json对象,如
var str = '{"name":"huangxiaojian","age":"23"}'
结果：
JSON.parse(str)
Object
1.	age: "23"
2.	name: "huangxiaojian"
3.	__proto__: Object
注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。
stringify()用于从一个对象解析出字符串，如
var a = {a:1,b:2}
结果：
JSON.stringify(a)
"{"a":1,"b":2}"

JSON.parse()【从一个字符串中解析出json对象】
例子：
//定义一个字符串
var data='{"name":"goatling"}'
//解析对象
JSON.parse(data)
结果是：
name:"goatling"
JSON.stringify()【从一个对象中解析出字符串】
var data={name:'goatling'}
JSON.stringify(data)
结果是：
'{"name":"goatling"}'
六，伪类伪对象
伪 对 象 不是真有对象，而是当成一个对象来使用，伪 对 象 用两个：：，伪类选择器是真的有这个对象
伪类（）：link，visited，hover，active，focus，first-child
伪对象(伪元素)：before，after，first-line，first-letter
单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。
伪元素由双冒号和伪元素名称组成。双冒号是在css3规范中引入的，用于区分伪类和伪元素。但是伪类兼容现存样式，浏览器需要同时支持旧的伪类，比如:first-line、:first-letter、:before、:after等。
对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。
提醒，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。
七，call apply bind
call和apply都可以用来改变函数里的this指向，区别是
call从第二个参数开始有多个参数，用来代表函数的实参
apply第二个参数是一个数组，数组中的每一个元素对应一个实参
<!--
function aa(name, age){
alert(this)
}

aa.call({name: 'lisi'}, 'lisi', 23);
aa.apply({name: 'lisi'}, ['lisi', 23]);
 -->
this指向
一个函数是直接调用的，this指向window。
一个普通函数里面的this指向的是window。
Call函数改变this指针。
call和apply的区别：aa.call({name:”lisi”},’lisi’,12);
aa.apply({name:”lisi”},[’lisi’,12]);
call和apply都执行函数，bind只是改变this的指针，而不执行。
aa.bind({name:’lisi’}).call();
八ajax原理，（兼容性）
<!-- AJAX = Asynchronous JavaScript and XML
    客户端浏览器向服务器数据交互的方式
-->

<!--ajax -->
<!-- $.get();
 $.post();
 $.ajax()-->
<input type="button" id="btn" value="click"/>
<div id="div1"></div>
<script>

    var oBtn = document.getElementById('btn');
    var oDiv1 = document.getElementById('div1');

    oBtn.onclick = function(){
        //1创建xmlhttprequrest对象
        if(window.XMLHttpRequest){
            var xmlhttp = new XMLHttpRequest();
        }else{
            var xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
        }

        //2、发送请求
//            get
        /*xmlhttp.open('GET','servers.php?name=xx',true);
         xmlhttp.send();*/

//            post

        xmlhttp.open('POST','servers.php',true);
        xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        xmlhttp.send('name=cc&age=20');

        xmlhttp.onreadystatechange = function(){

            if(xmlhttp.readyState == 4 && xmlhttp.status == 200){
                oDiv1.innerHTML = xmlhttp.responseText;

            }
//            console.log(xmlhttp.readyState)
        }
    };

    /* readyState有5种值：
     0: 请求未初始化
     1: 服务器连接已建立
     2: 请求已接收
     3: 请求处理中
     4: 请求已完成，且响应已就绪

     staus状态码常见的有：
     200 服务器成功返回
     301 永久重定向
     302 临时重定向
     404 资源找不到
     500 服务器错误*/

//    AJAX的优点
//    <1>.无刷新更新数据。
//    <2>.异步与服务器通信
九，异步加载async   defer
异步：不用等待。在script里面加上async
Defer和async看上去效果是一样的，defer是IE中支持的语法，在老的IE中支持defer。区别：async，等文件加载完就执行，但是不保证文件的执行顺序，比如123个Js文件同时异步加载，看谁快设先加载；defer加载时可以好几个文件都异步加载，dom结构加载完进行，理论上可以保证文件的加载顺序。

十。 sectionStorage  loaction  cookies
共同点：都是保存在浏览器端，且同源的。
区别：
 1、 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
  cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
2、存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，     sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
3、作用域不同，sessionStorage不在不同的浏览器窗口中共享（打开新窗口不行，哪怕是一个界面），即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的（谁存在那只有他自己能去取，别人取不到）。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。


十一，原型链
js继承机制
我知道一种基于原型的继承机制，举个例子来说：
假设有一个ClassA和ClassB，ClassB想继承ClassA
首先要在ClassA的构造函数里定义属性，在ClassA的原型里定义方法：
<!--
function ClassA() {
    this.color = sColor;
}
ClassA.prototype.sayColor = function () {
    alert(this.color);
};
-->
然后在ClassB的构造函数中使用ClassA.call(this)来继承ClassA中的属性：
<!--
function ClassB() {
    ClassA.call(this);
}
-->
再用ClassB.prototype等于ClassA的一个实例对象来继承ClassA中的方法：
<!--
ClassB.prototype = new ClassA();
ClassB.prototype.constructor = ClassB;
-->‘
十二，闭包
闭包：
    一个外部函数里面套一个内部函数，内部函数调用外部函数的局部变量，当外部函数执行完之后，变量不会释放；外部函数和内部函数结束的时间不一样，如果外部函数执行完之后，变量不想被释放，优点，变量不会被释放，缺点：会占据内存，手动释放变量。例如：函数立即调用，单击ul弹出li的索引。一个按钮，单击按钮让按钮运动，
   闭包在表象上是：外部函数声明内部函数，内部函数引用外部函数中的局部变量，这样当外部函数执行完毕时，局部变量不被释放。
例子：有许多个li，单击弹出li的索引。


闭包（一个外部函数里面套一个内部函数，外部函数调用内部函数的局部变量，当外部函数执行完之后，变量不会释放；外部函数和内部函数结束的时间不一样，如果外部函数执行完之后，变量不想被释放，优点，变量不会被释放，缺点：会占据内存，手动释放变量。例如：函数立即调用，单击ul弹出li的索引。一个按钮，单击按钮让按钮运动，）
十三，作用域链
JavaScript中所有的量都是存在于某一个作用域中的
除了全局作用域, 每一个作用域都是存在於某个作用域中的
在试图访问一个变量时JS引擎会从当前作用域开始向上查找直到Global全局作用域停止
例如

var A;//全局作用域function B(){    var C;//C位于B函数的作用域    function D()    {        var E;//E位于D函数的作用域        alert(A)    }}
当alert(A)时, JS引擎沿着D的作用域, B的作用域, 全局作用域的顺序进行查找.
这三个作用域组成的有序集合就成为作用域链

至于为什么叫链, 你可以理解和链表有相似之处, 深层的作用域会能够访问到上层作用域, 就如同链表中两个连续节点能够单向访问一样
作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。

十四，盒模型
十五    vue
 双向数据绑定原理
Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。
ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。


原理：
把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。

Vue.js特点
简洁：页面由HTML模板+Json数据+Vue实例组成
数据驱动：自动计算属性和追踪依赖的模板表达式
组件化：用可复用、解耦的组件来构造页面
轻量：代码量小，不依赖其他库
快速：精确有效批量DOM更新
模板友好：可通过npm，bower等多种方式安装，很容易融入

什么叫做虚拟dom:
	用JS对象表示DOM结构,当数据发生改变时.跟原来的dom树进行对比.通过在这个虚拟DOM上实现了一个diff算法找出最小变更，再把这些变更写入实际的DOM中。

虚拟dom具体如何实现?
	1>如何比较两个两棵DOM树
		我们很少跨级别的修改DOM节点，通常是修改节点的属性、调整子节点的顺序、添加子节点等。因此，我们只需要对同级别节点进行比较，避免了diff算法的复杂性。
对同级别节点进行比较的常用方法是深度优先遍历//
	深度优先遍历:也就深入的遍历，沿着每一个分支直到走到最后，然后才返回来遍历剩余的节点
		function diff(oldTree, newTree) {
		    //节点的遍历顺序
		    var index = 0;
		    //在遍历过程中记录节点的差异
		    var patches = {};
		    //深度优先遍历两棵树
		    dfsWalk(oldTree, newTree, index, patches);
		    return patches;
		}
	2>如何记录节点之间的差异
	由于我们对DOM树采取的是同级比较，因此节点之间的差异可以归结为4种类型：
			修改节点属性, 用PROPS表示
			修改节点文本内容, 用TEXT表示
			替换原有节点, 用REPLACE表示
			调整子节点，包括移动、删除等，用REORDER表示
		而当旧节点的属性被修改时：{type:PROPS,props: newProps}
		在深度优先遍历的过程中，每个节点都有一个编号，如果对应的节点有变化，只需要把相应变化的类别记录下来即可。
		比如对上文图中的两颗虚拟DOM树，可以用如下数据结构记录它们之间的变化：
		var patches = {
		        1:{type:REPLACE,node:newNode}, //h1节点变成h5
		        5:{type:REORDER,moves:changObj} //ul新增了子节点li
		    }
3>对真实DOM进行最小化修改
通过虚拟DOM计算出两颗真实DOM树之间的差异后，我们就可以修改真实的DOM结构了。上文深度优先遍历过程产生了用于记录两棵树之间差异的数据结构patches, 通过使用patches我们可以方便对真实DOM做最小化的修改。

MVVM MVC MVP区别
	MVVM:将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。
	MVC是比较直观的架构模式，用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。
	MVP:MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。
生命周期

15+父zi组件传值
父组件向子组件传值成功
总结一下：
•	子组件在props中创建一个属性，用以接收父组件传过来的值
•	父组件中注册子组件
•	在子组件标签中添加子组件props中创建的属性
•	把需要传给子组件的值赋给该属性
子组件向父组件传值成功
总结一下：
•	子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件
•	将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法
•	在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听
V-if v-show
•	）手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；
•	（1）手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；
•	（2）编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；
•	（3）编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；
•	（4）性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；
•	（5）使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。
•
•	Tips：（1）如果v-show作用的元素，css文件中display:none，通过v-show进行设置不能显示该元素；
•	原因：v-show控制显隐，是通过js代码去修改元素的element style，如果value为false，设置display: none;如果value为true，设置display: ''；于是value为true时，只能将element style中的display效果清除，并不能覆盖css中的display效果；
•	如下图所示，value=true时，v-show改变的是element.style，由于无效，显示效果由css文件中的display决定。
•
•

15++Webpack 实现原理
•	  1. Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)
•	  2. 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端
•	  3. 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash
•	  4. 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端
•	  5. 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档
•	  6. hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。

十六，跨域
<!--跨域（同源策略）->
<!--

有四种情况属于跨域

www.a.com   www.b.com    //域名不同
www.qq.com  news.qq.com  //主域子域     域名通过dns解析服务解析出来的IP地址，IP地址对应一台服务器  通过IP地址  域名访问是一个意思
http://192.168.100:81  http://192.168.100:8081 //端口号不一样
http://192.168.100     https://192.168.100     //协议不一样
（超文本传输协议）        （安全超文本传输协议）

-->

<!-- 网址  阿里大于（短信服务）-->
<!-- CDN 内容分发网络    用jQuery jQuery CDN节点
优点：
1.节省本地服务器空间
2.cdn加速，把自己的图片放到别人服务器上，从别人的服务器上调用
-->
<!--<script src="http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4151748604,35134
在网页里边所有带src属性的都支持跨域
这个允许跨域

-->
<!--
解决跨域问题
1.jsonp：json padding(json跨域方式，jsonp是一种格式)
通过script的src加载另一个域的一个文件，通过src这个url用get方式把这个值从一个域传到另外一个域
script标签不会判断你引入的设么文件，只要js能执行就行

js的function aa（可以传json格式的对象）  // 属性比较多的时候
后边调用前端的函数的时候，前端可以在通过jsonp的src、get传函数名的时候将函数明写成callback=函数名

实现：利用script标签的src属性，支持跨域，通过后台接口返回一个回调函数的调用，
函数是声明在我们页面的回调函数
也可以动态生成script标签

<script src="http://www.b.com/test.php?name=zhangsan&age = 18&callback=fn"></script>
b域
<?php
    $username = $_GET["name"];
    $age      = $_GET["age"];
    $function = $_GET["function"];
    <!--echo "$function('$username')";-->
<!--将这个函数值传给a域-->
    <!--echo "$callback('$username')";-->
?>

<!--2.iframe跨域-->
<!--iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。-->
<!--描述与实现： 在a域下的index.html通过iframe去访问b域下的index.php，get传参。b域能接收到这个参数，
    调用父级页面方法涉及跨域问题，（top。aa子域访问父域，但是不支持跨域），再在a域下建一个index2.php文件,把b域参数传到a域下的index2.php
    ，再调用top方法-->

<!--（iframe,在一个HTML文件里写出iframe标签，src是另一个HTMl，iframe就把另一个HTML嵌入到最开始的HTML里了）-->
<!--iframe 把代码直接写在body里而且不执行代码，在外边套一个script标签  ，  而且子页面里的不能直接访问父元素的方法，就得用top

echo "<script>top.bb("dff") </script>"
-->

<!--
不推荐使用iframe，因为缺点1.使dom结构变的复杂2.搜索引擎抓取不到iframe的内容

3.利用后端实现：（不通过前端在本域下直接通过后端发送数据请求，后台在传给b域的后台，（后端服务器没有跨域问题）
  计算完后返回我们的后台，再通过后台传给前台  ，  a前--》a后--》b后（算）--》a后--》a前 ）

4.服务器代理方式：在后台最前面加个请求头，允许跨域的请求头：header("Access-Control-Allow-Origin:http://www.a.com");

同源策略：只允许相同域下访问数据；

4.postmessage（h5）//兼容
3.PostMessage（h5支持语法  ie67不支持）
A域下的index.php
B域下面

E.data的值就是hello那个字符串




5.window.name//
6.CORS跨域（IE10）
      它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
      实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

-->

<!--
下面不属于跨域
(同一个域名，同一个协议，不同文件不属于跨域)
http://www.a.com/index1.html;
http://www.a.com/index2.html;
-->
十七、计算机网络：1
应用层：哪些协议  ：  http**（状态码）**  ftp（文件传输） smtp（右键）
表示层
会话层
传输层：协议tcp （3c，4h）可靠数据传输，udp不可靠（没反馈），游戏
网络层：根据ip，路由器
数据链路层：交换机，mac地址
物理层：光纤那层传播

十八、get post（包体）区别
get重点在从服务器上获取资源，post重点在向服务器发送数据
post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
1.使用GET时，数据作为URL的一部分，在地址栏中显示，不太安全。
2.get传送的数据量较小，不能大于2KB。
   post传送的数据量较大，一般被默认为不受限制。
3.使用POST时，数据集会被编码到http协议的body中，构造成消息发送。
4.get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
post支持标准字符集，可以正确传递中文字符
5. get请求头，放在地址栏不安全，post包体，
多次请求都返回同样的结果时使用GET，而当请求会改变服务器数据或状态时使用POST

十九，三次握手
第一次握手：客户端向服务器端发送请求（SYN=1） 等待服务器确认；
第二次握手：服务器收到请求并确认，回复一个指令（SYN=1，ACK=1）；
第三次握手：客户端收到服务器的回复指令并返回确认（ACK=1）。
TCP四次挥手：关闭连接
(1) Client端向Server端FIN报文，请求关闭连接
(2) Server端发送ACK，表示收到请求。但是Server端还有数据没有发送完成，则不必着急关闭Socket，可以继续发送数据。这时Client端进入FIN_WAIT状态，等待Server端的FIN报文。
(3)当Server端确定数据已发送完成，则向Client端发送FIN报文，表明可以关闭连接了
(4)Client端收到FIN报文后，知道可以关闭连接了，再发送ACK，后进入TIME_WAIT状态，Client端等待了2MSL(最大报文生存时间)后依然没有收到回复，则证明Server端已正常关闭，然后Client端也可以关闭连接了，进入Closed状态。
Server端收到ACK后，就关闭连接了。如果Server端没有收到ACK，那么将重发FIN。

二十 优化：
 1.代码层面的优化
	 1。提高JS代码复用性，缩小JS文件大小。
	 2。减少DOM选择和计算，dom操作，变量操作的结果缓存，下次直接使用缓存结果
	 3。CSS文件优化，正确使用display属性，否则会影响页面的渲染；不滥用float；不申明过多的fontsize；标准化各种浏览器的前缀；避免使用高级的选择器，耗时长，尽量使用id，class选择器，避免使用内联style；尽量使用css3动画
	 4。资源加载，按需加载和异步加载；
	 5。压缩所有的html css js
	 6。减少重绘和回流；
	 7使用touchstart，touchend click；
	 8html中使用viewport；
	 9。touchmove scroll事件会导致多次渲染；
	 10。避免空的src 减少html中的src请求
2框架级优化
	使用第三方资源时，由于资源不可控，所以要慎选择。要根据项目需求和其对比性的影响去综合考虑，选择合适的框架以及库文件，同时使用异步加载的方式去加载，避免第三方资源的使用影响项目本身的性能。
3域名\服务端的优化
	1.使用压缩资源；
	2.资源缓存，合理设置资源的过期时间；
	3.减少cookies，减少cookies头信息的大小，否则会影响传输速度；
	4.CDN加速，图片或者css，js均可以使用cdn来加速。
4服务器端优化
	1.接口合并，如果一个页面需要请求两部分以上的数据接口，则建议合并成一个，可以减少http请求；
	2.减少数据量，去掉接口返回的数据中不需要的数据；
	3.缓存数据，首次加载请求一次后，缓存下数据；非首次请求优先使用上次请求的数据，可以提高非首次请求的加载速度
二十一，h5的语义化有什么
1，有关HTML的语义化，你的理解：html中自带了一些标签，这些标签有特定含义，比如H1-H6代表标题、p代表段落、img代表图片、html5里也推出了一些新的标签：header、footer、nav这些标签都有特定的含义，使用的时候应该尽量按照它的语义来使用
好处：1.别人阅读你的代码的时候能够根据标签才出来你的用意，有利于程序员阅读，便于团队开发和维护
2.浏览器读取方便
3.有利于搜索引擎优化（SEO：Search Engine Optimization）（比如说会根据标签来搜索，可能重点会搜索h1）
4、有一些标签默认会有一些样式，如果浏览器禁止了CSS样式还可以达到突出样式的效果，比如h1
二十二
居中
外边框合并
浮动
二十三 浏览器输入地址会出现什么事情
发送get请求给dns（域名解析服务器），再给相应的ip地址对应的服务器，服务器响应给客户端给浏览器
1. 浏览器会发送一个get请求，该请求会被转发到DNS服务器，由DNS服务器解析域名，然后再转发到相应的IP地址对应的服务器。
	2. 在服务器端由Apache这样的Web Server来接收请求，并进行相应的处理，然后响应结果给客户端浏览器。
	3. 浏览器接收响应的结果，并进行相应的语法检查，如果有错误，可能会提示错误，如果没有错误，就进行渲染。
	4. 渲染的时候先生成DOM树，然后根据CSS和JS规则生成渲染树（渲染树中的结构往往比DOM树要少，因为有些DOM树中有些元素如果隐藏的话，不会出现在渲染树中），最后再渲染出来
二十四 boostrap 怎么实现栅格布局
首先，我们要为页面内容和栅格系统包裹一个 .container
类用于固定宽度和响应式布局的容器，如果占据 100% 的宽度，使用  .container-fluid 类：
栅格系统会根据屏幕和视口（viewport）的尺寸，将一行分为最多 12 列，通过预设好的栅格类表示需要占多少个列宽度。
•	.col-xs-* ：超小屏幕、手机 (<768px)
•	.col-sm-* ：小屏幕 平板 (≥768px)
•	.col-md-* ：中等屏幕 桌面显示器 (≥992px)
•	.col-lg-* ：大屏幕 大桌面显示器 (≥1200px)

二十五 判断数组
1.alert(arr instanceof Array); // true
2.alert(arr.constructor === Array); // true
3.return Object.prototype.toString.call(o) === '[object Array]';
}
var arr = [1,2,3,1];
alert(isArrayFn(arr));// true
4.Array.isArray()
二十六 兼容性
列举CSS兼容性：1. 透明度问题，标准浏览器(0-1)opacity:0.2，IE (0-100);filter:  alpha(opacity=20);
2、IE6不支持display：inline－block （inline-block属性值，使其既具有block的可以设置宽高度特性，又具有inline的同行特性）（_display:inline;）3、（在css参考手册中有许多问题和解决方案）在IE6及更早的浏览器中定义小高度容器(因为默认有字体、行高)：overflow:hidden;font-size:0;height:1px;line-height:0;
4，IE6中浮动式产生一个双边距的问题：把元素的display:inline
5，IE6之间的浏览器不支持min-height，解决：加一个_height:200px;
6、CSShack（利用了这些浏览器的漏洞价格，专门用这些漏洞来解决兼容性问题）:条件hack、属性级hack（_color:IE6；*color:IE7；color:#090\9:IE6+ ）、选择符级hack3	（*html是IE6；*+html是IE7），
7.被点击过的超链接不再具有hover、active了
   解决：CSS属性排列顺序 Link-Visit-Hover-Active
把：hover ：visit之类的里面的样式设置成一样的
7、IE中有一个3像素BUG，当一个元素浮动，另一个元素和他并列是会有一个3像素的边距，给左边浮动的元素加一个_margin-right :3px来解决。负值往右，正值往左
.aa{
    width: 200px;
    height: 200px;
    float: left;
    background: #ff0000;
    _margin-right:-3px;
}
.bb{
    /*float: left;*/
    background: #0000ff;
    width: 200px;
    height: 200px;
}

9.  IE6只支持 a标签的：hover，不支持其他标签的：hover
10. IE6不支持png24的透明（png透明）1.通过滤镜解决2.引入js（不好。性能）

CSS3中很多东西在IE中都不支持，手册中有CSS中的常见问题。
hack
(引入条件hack，引入一个css文件）
<!—[if IE 6]>
<script src=”DD_belatedPNG_0.0.8a.js”></script>
<script>
DD_belatedPNG.fix(‘*’);
</script>
<![endif]-->条件级hack，解决IE6下面不支持png透明问题
如果想要页面支持IE6，在head里面写
<!—[if IE 6]>
<link rel=”stylesheet” href=”ie6_sb.css”/>
<![endif]-->
条件hack:
<!--[if IE 6]>
<style>
#div1{
background: red;
}
</style>
<link rel="stylesheet" href="ie8.css">
<![endif]—>
单独为IE6写一个CSS样式做兼容，不需要就删
属性级hack:
p{
color: #00ff00;
color: #ff0000\9;    //IE8+
*color: #ff0000;     //IE7及以下
_color: #00ff00;     //IE6及以下
}
选择符级hack:
* html .test{     //IE6及以下
color: red;
}
* + html .test{  //IE7
color: yellow;
}

二十七 H5和css3
css3  HTML5 新特性
css3

1、圆角：border-radius
•1个：都一样 border-radius: 一样
•2个：对角 border-radius: 左上&右下 右上&左下
•3个：斜对角 border-radius: 左上 右上&左下 右下
•4个：全部，顺时针 border-radius: 左上 右上 右下 左下
•border-radius: 1-4个数字 / 1-4个数字——前面是水平半径，后面是垂直半径border-radius: 10px/5px;
•不给“/”则水平和垂直一样
2、边框
（1）边框图片：border-image
•border-image-sourceg 引入图片
•border-image-slice 切割图片
•border-image-width 边框宽度
•border-image-repeat 图片的排列方式：round 平铺,repeat 重复,stretch拉伸
（2）边框颜色 border-colors（火狐下）
3、线性渐变
（1）格式
•线性渐变格式 linear-gradient([<起点> || <角度>] ?<点>, <点>…)
•只能用在背景上
（2）参数
•起点：从什么方向开始渐变
默认：top left（左上角）
•角度：从什么角度开始渐变
xxx deg的形式（逆时针旋转）
•点：渐变点的颜色和位置
black 50%，位置可选
（3）实例：background-image:-webit-linear-gradient(60deg,red 0,blue 40%,green 100%)
（4）平铺：background：-webit-repeating-linear-gradient(15deg,green ,green 10px,#fff 10px,#fff 20px,);
（5）兼容IE9以下:（gradientType=1为从左往右，0为从上往下）
　filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff',endColorstr='#ff0000',GradientType='1');　　
7，css3动画：
1.变形transform（只有变形没有动画）（-webkit-transform:;）：
旋转rotate(围绕x、y、z三个方向)、
缩放scale（水平，垂直）、
 位移translate(比 position 效率高，translateX translateY translateZ,逗号分隔)、
扭曲skew（水平，垂直，单位是度数deg）
矩阵matrix
scale3d
2.过渡transition（只要改变值就动，过度比较平滑）：做动画的属性(width, all)，动画执行时间，动画形式，延迟时间
（给一个初值，初值一改变就执行动画）
-webkit-transition-property: all;
-webkit-transition-duration: 2s;
-webkit-transition-timing-function: ease;
-webkit-transition-delay:1s;
-webkit-
-moz-
-ms-
-o-
3.动画animation（调用了就动）：
动画名称animation-name、执行时间animation-duration、动画函数animation-timing-function、延迟animation-delay、执行次数animation-iteration-count (infinite无限次  n次)、方向animation-direction(normal正常  alternate轮流反向) 、保持最终状态forwards
animation(适合复杂动画，就是为了分多阶段)
.stress{
    animation:   stress   1s   forwards;
    -webkit-animation:   stress   1s   forwards;}
@keyframes stress{
    from{}
    to{  background: #ee0;   }
}
@-webkit-keyframes stress（动画名字）{
    from{}                      0%{}
    to{background: #ee0;}               100%{}
}
4.3d变换，围绕xyz轴方向
如果有多级元素进行3D变换，把perspective加在最外层身上，子元素加上transform-style : preserve－3d
保持3d：transform-style : preserve－3d
视角－webkit－perspective： 800； 不是伪3d，为了呈现3d效果，加在父元素上
视角原点－webkit－perspective-origin： 50% 50%；加在父元素上
4、径向渐变
（1）格式
•线性渐变格式 radial-gradient([<起点>]? [<形状> || <大小>]?  <点>, <点>…)
（2）参数
•起点：可以是关键字（left,top,right,bottom），具体数值或百分比
•形状：ellipse（椭圆）、circle（圆形）
•大小 :具体数值或百分比，也可以是关键字（最近端，最近角，最远端，最远角，包含或覆盖 (closest-side, closest-corner, farthest-side, farthest-corner, contain or cover)）;
•点：渐变点的颜色和位置
black 50%，位置可选
5、背景
（1）多背景：逗号分开 background: url(a.jpg) 0 0, url(b.jpg) 0 100%;
（2）背景尺寸：background-size:x y
•background-size:100% 100%
•Cover 放大
•Contain 缩小
（3）背景原点：background-origin ： border | padding | content
•border-box： 从border区域开始显示背景。
•padding-box： 从padding区域开始显示背景。
•content-box： 从content区域开始显示背景。
（4）背景裁剪：background-clip： border | padding | content|no-clip
•border-box： 从border区域向外裁剪背景。
•padding-box： 从padding区域向外裁剪背景。
•content-box： 从content区域向外裁剪背景。
•text： 从文本区域向外裁剪背景。（仅支持webkit内核浏览器）
h5
/* 1. 新的语义化标签，比如header、footer、nav、article等
2. 新增表单控件: input type="email/number/range。。。"
3. 新的选择器：querySelector和querySelectorAll
4. json的方法：JSON.parse()和JSON.stringify()方法
5. 历史管理：history.pushState()和window.onpopstate事件
6. 本地存储：localStorage和sessionStorage（可能会问和cookie）
7. Canvas画布：
var cvs = document.getElementById('canvas1');
var cxt = cvs.getContext('2d');*/
HTML5  的新的表单属性
新增了语义化的标签：header\nav\footer
新增了一些表单控件和表单属性
新增了音频、视频
新增了新的选择器：querySelector\querySelectorAll\getElementByClassName
新增加了一些json的新的方法：parse\stringify（对象拷贝，先把对象转化成字符串，再转化成json）
新增了历史管理、本地存储
新的 form 属性：
•autocomplete
•novalidate
新的 input 属性：
•autocomplete
•autofocus
•form
•form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)
•height 和 width
•list
•min, max 和 step
•multiple
•pattern (regexp)
•place older
•required
HTML5 提供了两种在客户端存储数据的新方法：
•localStorage - 没有时间限制的数据存储
•sessionStorage - 针对一个 session 的数据存储
HTML5 <canvas> 标签用于绘制图像（通过脚本，通常是 JavaScript）。
不过，<canvas> 元素本身并没有绘制能力（它仅仅是图形的容器） - 必须使用脚本来完成实际的绘图任务。
getContext(2d) 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性
。

二十八 sass scss
Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：
1.	文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名
2.	语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。
先来看一个示例：
Sass 语法
$font-stack: Helvetica, sans-serif  //定义变量
$primary-color: #333 //定义变量

body
  font: 100% $font-stack
  color: $primary-color
SCSS 语法
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
编译出来的 CSS
body {
  font: 100% Helvetica, sans-serif;
  color: #333;
}
一. Sass/Scss、Less是什么?
Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。
Sass与Scss是什么关系?
Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。
Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数.  Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。
二. Sass/Scss与Less区别
1.编译环境不一样
Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。
2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。
3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。
输出样式的风格可以有四种选择，默认为nested
•	nested：嵌套缩进的css代码
•	expanded：展开的多行css代码
•	compact：简洁格式的css代码
•	compressed：压缩后的css代码
4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。
5. 引用外部CSS文件
6.Sass和Less的工具库不同

https://www.cnblogs.com/wangpenghui522/p/5467560.html
二十九 浏览器内核
Trident	  ie
Presto      opera
Gecko     mozilla
Webkit	     google\safri
三十 垃圾回收
	目前JS的垃圾回收机制无非就是两种：1.标记清除（make-and-sweep） 2.引用计数（reference counting）
	1.标记清除：标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。
	2.引用计数（查了很多资料，还是无法找到其真正的计算方式）
	一般来说，引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法访问到它了，因而可以将其占用的内存空间回收
三十一 、在浏览器地址栏里输入一个地址，按回车发生了什么？
	1. 浏览器会发送一个get请求，该请求会被转发到DNS服务器，由DNS服务器解析域名，然后再转发到相应的IP地址对应的服务器。
	2. 在服务器端由Apache这样的Web Server来接收请求，并进行相应的处理，然后响应结果给客户端浏览器。
	3. 浏览器接收响应的结果，并进行相应的语法检查，如果有错误，可能会提示错误，如果没有错误，就进行渲染。
	4. 渲染的时候先生成DOM树，然后根据CSS和JS规则生成渲染树（渲染树中的结构往往比DOM树要少，因为有些DOM树中有些元素如果隐藏的话，不会出现在渲染树中），最后再渲染出来

三十二、link标签和import标签区别：
　　区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
　　区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
　　区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。
三十三、超出内容省略号
	overflow:hidden
	text-overflow:ellipsis省略号;clip裁切
	white-space:nowrap;换行
三十四 、require.js

	AMD,模块化开发,解决依赖的问题.
	原理：<data-main属性加载入口文件，在底层动态创建script标签，用正则表达式匹配加载的入口文件名，动态的创建标签，动态的加载。>
		1.在入口函数main.js里面定义的require方法或者define方法，requireJS会把这些  依赖和回调方法  都用一个数据结构保存起来。
		2.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。
		3.当js里需要用到依赖所返回的结果时,requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。
	seajs 底层怎么实现的，先判断依赖关系，先把函数变成一个字符串，只需要正则表达式来匹配require关键词后面的引用关系即可。当前模块在加载所依赖的模块的是，所依赖的模块同样也需要进行这一过程，直到所有的依赖都加载执行完毕，当前模块才开始执行

弹出层
定义模块用define
想使用一个模块，而自己不是模块，用require

把类实例化对象 new
属性构造函数 方法原型
options = $_extend({ },options)默认的样式

jquery.js解决的是DOM操作，兼容性的问题;require.js解决的是模块化开发的问题
alert就是弹出窗口，提示信息；confirm是与用户交互，让用户选择，做进一步的处理；prompt用来接收用户的输入。原生弹窗

三十五 、AMD，CMD区别
	AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。(依赖前置)
	CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。(依赖就近)
	区别：
	1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行。CMD 推崇 as lazy as possible.
	2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：
	// CMD
	define(function(require, exports, module) {
	var a = require('./a')
	a.doSomething()
	// AMD
	define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
	a.doSomething()
	})
三十六 jq原理
	jq最核心的是$,他是一个函数.函数中返回一个自定义的jq对象,她是一个类,在这个类的原形下有许多jq自定义的方法.每次调用$返回一个新的jq对象,同时在$函数中根据传入参数的类型,函数或者字符串.
	把选中的元素存在数组中,遍历这个数组,取出每个元素进行dom操作.
	在每一个方法中,return this,this就是在$函数中返回的jq对象..
三十七 jq常见优化方案
1. 缓存jq对象，如：var $div1 = $('#div1');
	2. 在原生的js没有什么兼容性的情况下，可以尽量使用原生的js，因为jq的效率比较低
	3. 在使用$选择器的时候应该指定上下文，提高搜索速度
	4. 合理的使用事件委托
三十八 jq中的事件绑定
	1. on()这个是现在标准和推荐的方法
	// on函数的第二个参数用来指定一个选择器，当使用这个选择器的时候，就可以实现事件委托
	2. 以前还有直接:
		click(function(){});
	3. live：专门是用来给后生成的元素绑定的（用js动态生成的元素）
	4. one 只执行一次
	5. delegate 事件代理
	6. bind：就是通用的事件的绑定方法
三十九 jq优点:
2.JQuery的特点
	(1).强大的DOM选择器(CSS1-3 + XPath)
	(2).解决兼容性问题
	(3).有现成的组件
	(4).可扩展性强。(自己封装jq插件)
	(5).事件、样式、动画支持。
	(6).Ajax操作支持。
四十 你常用JQ方法有哪些，给我简单介绍一下
	一、选择器、:eq(),:has(),p:nth-child(2)(是p元素,且是父元素的第二个子元素)p:nth-of-type(2)(父元素的第二个p元素)
    nth-child（）（1开始），其余都是0开始
	二、属性CSS、
	   1） .prop与.attr区别:
			对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。
			对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。
	   2）.innerHeight/innerWeight(包括padding不包括border)
	          outerHeight()outerHeight(true)(包括border,如果true的话加margin)
	   3）.offset相对于文档.position相对于最近已定位的父元素

	三、dom操作、
	.remove() 将元素移出DOM。 当我们想将元素自身移除时我们用 .remove()，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。要删除的元素不删除数据和事件的情况下，使用.detach()来代替。。
	当需要移走一个元素，不久又将该元素插入DOM时用.detach()
	四、遍历、.eq()/.siblings()
	五、事件、
	        .end连续 . 操作
	六、效果 .hide()/.toggle()
四十一 svn和git的区别:
	1、Git是分布式的，SVN是集中式的，好处是跟其他同事不会有太多的冲突，自己写的代码放在自己电脑上，一段时间后再提交、合并，可离线提交，
	SVN在Commit前，我们都建议是先Update一下，跟本地的代码编译没问题，并确保开发的功能正常后再提交。Git可能这种情况会少些
四十二  git命令
		git help <command> # 显示command的help
		git show # 显示某次提交的内容 git show $id
		git co -- <file> # 抛弃工作区修改
		git co . # 抛弃工作区修改
		git add <file> # 将工作文件修改提交到本地暂存区
		git add . # 将所有修改过的工作文件提交暂存区
		git rm <file> # 从版本库中删除文件
		git rm <file> --cached # 从版本库中删除文件，但不删除文件
		git reset <file> # 从暂存区恢复到工作文件
		git reset -- . # 从暂存区恢复到工作文件
		git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
		git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am "some comments"
		git ci --amend # 修改最后一次提交记录
		git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象
		git revert HEAD # 恢复最后一次提交的状态

四十三 、图片预加载
	for(){
		var img=new Image();

		img.onload=function（）{
			计数
			loadSuccess（）
		}
	}
		img.src=ghjg//注意顺序问题（ie6下不好使）
		图片排序

四十四、懒加载
	先把img的src指向一个小图片，图片真实的地址存储在img一个自定义的属性里,<img src="lazy-load.png" data-src="xxx" />,等到此图片出现在视野范围内了，获取img元素，把data-src里的值赋给src。

如何判断是否出现在可视区域内吗？ 那就是你可以获取当前img的相对于文档顶的偏移距离减去scrollTop的距离， 然后和浏览器窗口高度在进行比较，如果小于浏览器窗口则出现在了可视区域内了， 反之，则没有。

四十五、setTimeOut中改变this指向问题解决办法
		1\setTimeout(function() {
				alert(this.name);
			}.bind(this), 1000);
		2\setTimeout(function() {
				var that=this;   //setTimeout 里面的this 指向window
				alert(that.name);
			}, 1000);
		3\setTimeout(()=>{   //使用箭头函数
						alert(this.name);
					}, 1000); // 张三

四十七、想要往setTimeout里传参
	var fn = function(name){
	       alert(name);
	}
	setTimeout('fn("lisi")',2000)
四十八、宽度
	styleWidth：content/
	clientWidth：content/padding
	offsetWidth：content/padding/border
	scrollWidth:实际内容(有滚动条情况下)
	jq
	.width()/内容
	.innerHeight/innerWeight(包括padding不包括border)
.outerHeight()outerHeight(true)(包括border,如果true的话加margin)
四十九、js数据类型:
       基本数据类型:string number boolean null undefined
           undefine：定义了没赋值，函数的参数没有传值，访问对象中没有的属性，访问超过数组长度的值
           null：指代是对空对象的引用（对象的占位符）
       引用数据类型:obj(是保存在堆内存中的对象)

	   基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。

	   而引用类型值则是指那些保存在堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。
49.1\typeof（判断数据类型）
	console.log（typeof undefine）;//undefined
	console.log（typeof null）;    //object  (早期js的设计错误，被延续下来，null可以指代一个空对象)
	console.log（typeof function(){}）; //function
	console.log（typeof []）;//object

	constructor（返回创建类的构造函数）
	instanceof(是谁谁的实例)
	isArray（是不是数组）(ES5,ie8不支持)
	.toString（Object中默认调用的方法，用来返回该对像的字符串形式,找其原型链的toString方法）



五十、JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。
		1.内部对象
			js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。
		其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。
		2.宿主对象
		  浏览器对象:如Window和Document等等。navigator对象表示浏览器的信息，最常用的属性包括：screen;location对象表示当前页面的URL信息。例如，一个完整的URL：
3.	自定义对象


五十一、js一个有三种方法创建对象，
	1.对象直接量
		var obj2 = {
		  name: "ys",
		  age: 12
		};

	2.new创建对象
		1\系统内置对象var obj2 = new Array();
		2\自定义对象var obj1 = new Object();

	3./Object.create()创建
		var obj1 = Object.create({
		  name: "ys",
		  age: 12
		});
五十二linx命令:
56\linx命令:
	ls:显示文件或目录
	mkdir:创建目录
	-p:创建目录，若无父目录，则创建p(parent)
	cd:切换目录
	touch:创建空文件
	echo:创建带有内容的文件。
	cat:查看文件内容
	cp:拷贝
	mv:移动或重命名
	rm:删除文件
	find : 在文件系统中搜索某文件
	wc : 统计文本中行数、字数、字符数
	grep : 在文本文件中查找某个字符串

五十三移动端,点透 tap事件
原因:zepto的tap事件是通过兼听绑定在document上的touch事件来完成tap事件的模拟的，并且tap事件是冒泡到document上触发的！！！而在冒泡到document之前，用户手的接触屏幕(touchstart)和离开屏幕(touchend)是会触发click事件的,因为click事件有延迟触发(这就是为什么移动端不用click而用tap的原因)(大概是300ms,为了实现safari的双击事件的设计)，所以在执行完tap事件之后，弹出来的选择组件马上就隐藏了，此时click事件还在延迟的300ms之中，当300ms到来的时候，click到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有click事件此时便会触发，


		1\ouchstart->touchend->click。亦即click的触发是有延迟的，这个时间大概在300ms左右。
			.on('touchstart',function(){
				e.preventDefault();
			})

		2\引入fastclick.js，因为fastclick源码不依赖其他库所以你可以在原生的js前直接加上

		3\用touchend代替tap事件并阻止掉touchend的默认行为preventDefault()

		4\延迟一定的时间(300ms+)来处理事件
		5\???????????css3


	58\rem\em
		EM是相对于其父元素来设置字体大小的
		Rem是相对于根元素<html>
		px是固定单位，其实Px也不是绝对固定的，也算是相对的，比如在普通屏幕和视网膜屏上，1px就不一样

	59\input右侧输入
		<input style="text-align:right" />
		<input type="text" dir="rtl" />

	60\移动端框架
		jquery mobile（依赖于jquery，太重了，不常用，后来模块化了，只需引入需要的模块）
		zepto.js（轻量级框架，模块化，核心文件很小，流行，语法与jquery雷同,以$开头）

	61\webview，我知道
		我了解的是微信自己有一个webview，在这个webview有一些相应的jsapi接口，我们可以直接使用这些接口，但是这些接口并不需要考虑一些安全问题，因为如果你在微信以外访问，微信是不允许的，可它会提示必须要微信客户端访问

	61.1\jquery mobile:用data-role="header/footer/page"
			一个web app 中可以有多个page ，每个page又一个唯一的id标识，多个page之间通过 href 链接，
			首页id值应为“index”，这样jQM会将其默认为首页
			地址栏中： href＃页面id
			data－role＝”navbar“ 导航栏
			header，footer设置data-position="fixed"就固定定位了
			data－icon＝”camera“ 添加图标
			<ul data－role＝”listview“ data-inset="true"> 添加列表
			左右内边距
			表单
			<form id＝“多个page中必须唯一”>
				<label></label>
				<input>
			</form>

			表格table：data-role="table" data-mode="reflow"
			回流表格模式，屏幕宽时，就是普通表格布局，设置几个td就是几个td。屏幕窄时，可能变成一个td，多个td上下堆叠。

			jQM中推荐使用：
			$(document).on("pageinit","#page",function(){
			});


构建工具grunt
	Grunt 依赖 Node.js 所以在安装之前确保你安装了 Node.js。然后开始安装 Grunt。
	安装\grunt-cli	[npm install -g grunt-cli;]
	在本地建立grunt文件夹
	进到文件夹下	[npm init]初始化
	写入一个name(不要写grunt)[test],生成配置文件package.json
	建立Gruntfile.js文件,在里面配置任务,

五十四：模式

56\设计模式:单例，工厂，代理，装饰，观察者模式等

单例模式：单例模式的定义是产生一个类的唯一实例

判断这个对象是否存在，如果存在，就使用之前创建的。不存在就创建新的。

工厂：
	简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例经常都拥有相同的接口. 这种模式主要用在所实例化的类型在编译期并不能确定， 而是在执行期决定的情况。


 观察者模式：
　　观察者模式( 又叫发布者-订阅者模式 )应该是最常用的模式之一


